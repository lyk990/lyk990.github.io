<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AOP在前端编程中的应用</title>
    <url>/posts/4e6f4a5d/</url>
    <content><![CDATA[<p>最近在学代码优化的时候，看到了AOP(面向切面编程)，听着好像挺厉害的，就把他记录了下来</p>
<h2 id="什么是AOP"><a href="#什么是AOP" class="headerlink" title="什么是AOP"></a>什么是AOP</h2><p>面向对象的特点是继承、多态和封装。而封装就要求将功能分散到不同的对象中去，这在软件设计中往往称为职责分配。实际上也就是说，让不同的类设计不同的方法。这样代码就分散到一个个的类中去了。这样做的好处是降低了代码的复杂程度，使类可重用。  </p>
<p>但是人们也发现，在分散代码的同时，也增加了代码的重复性。什么意思呢？比如说，我们在两个类中，可能都需要在每个方法中做日志。按面向对象的设计方法，我们就必须在两个类的方法中都加入日志的内容。也许他们是完全相同的，但就是因为面向对象的设计让类与类之间无法联系，而不能将这些重复的代码统一起来。  </p>
<p>也许有人会说，那好办啊，我们可以将这段代码写在一个独立的类独立的方法里，然后再在这两个类中调用。但是，这样一来，这两个类跟我们上面提到的独立的类就有耦合了，它的改变会影响这两个类。那么，有没有什么办法，能让我们在需要的时候，随意地加入代码呢？<strong>这种在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是AOP(面向切面的编程)。</strong>  </p>
<p>一般而言，我们管切入到指定类指定方法的代码片段称为切面，而切入到哪些类、哪些方法则叫切入点。有了AOP，我们就可以把几个类共有的代码，抽取到一个切片中，等到需要时再切入对象中去，从而改变其原有的行为。</p>
<p>这样看来，AOP其实只是OOP的补充而已。OOP从横向上区分出一个个的类来，而AOP则从纵向上向对象中加入特定的代码。有了AOP，OOP变得立体了。如果加上时间维度，AOP使OOP由原来的二维变为三维了，由平面变成立体了。从技术上来说，AOP基本上是通过代理机制实现的。</p>
<p><a href="https://www.iteye.com/blog/hejiajunsh-1776569">上面的这一段话附上链接</a></p>
<h2 id="为什么会叫做切面"><a href="#为什么会叫做切面" class="headerlink" title="为什么会叫做切面"></a>为什么会叫做切面</h2><p>AOP的主要思想是将应用程序中存在耦合的功能模块进行封装，这些模块通常与核心业务逻辑无关，但是在应用程序的多个地方都需要进行处理。<br>例如：一个网站，存在以下几个功能</p>
<ul>
<li>登录</li>
<li>注册</li>
<li>日志记录</li>
</ul>
<p>登录、注册就是核心业务逻辑，而日志记录则不属于核心逻辑，但是多个地方都需要复用。在AOP中，就可以将日志记录的逻辑定义为一个切面，然后通过配置或代码来指定在哪个地方来应用这个切面。</p>
<p>在面向对象编程中，很多业务逻辑都在混杂在一起，导致代码的可读性和可维护性下降。AOP就是将这些非核心业务逻辑抽离出来，形成独立的模块，然后通过一种<strong>切面</strong>的机制，AOP框架会在编译时或者运行时，将其动态的织入应用程序的核心逻辑中。</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 出自JavaScript设计模式与开发实践3.2.3（高阶函数实现AOP）</span></span><br><span class="line">  <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">before</span> = <span class="keyword">function</span> (<span class="params">beforeFn</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> _self = <span class="variable language_">this</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">          beforeFn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">          <span class="keyword">return</span> _self.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">after</span> = <span class="keyword">function</span> (<span class="params">afterFn</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> _self = <span class="variable language_">this</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">          <span class="keyword">const</span> ret = _self.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">          afterFn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">          <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> func = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      func = func</span><br><span class="line">        .<span class="title function_">before</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">        .<span class="title function_">after</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="title function_">func</span>();</span><br><span class="line">      </span><br><span class="line">    输出:</span><br><span class="line">      <span class="number">1</span></span><br><span class="line">      <span class="number">2</span></span><br><span class="line">      <span class="number">3</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>看着好像非常疑惑，这样写的意义何在，这些代码主要是为了帮助理解AOP。其实简单来讲就是，通过函数调用，找到对应的切入点（PointCut），再从切入点中对应的织入（Weaving）动作，这样来实现逻辑解耦。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li>书籍： JavaScript设计模式与开发实践</li>
<li><a href="https://zhuanlan.zhihu.com/p/269504590">简谈前端开发中的AOP(一) – 前端AOP的实现思路</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/468837058">简谈前端开发中的AOP(二) – 前端AOP的发展与完善</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端架构管理</tag>
      </tags>
  </entry>
  <entry>
    <title>AOP装饰函数在前端中的应用</title>
    <url>/posts/803cab72/</url>
    <content><![CDATA[<blockquote>
<p>在传统的面向对象编程中，给对象添加功能常常采用继承的方式，但是继承的方式并不灵活。在实现一些功能时，有可能会创建出大量子类</p>
</blockquote>
<h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><p>在JavaScript中可以很方便的给某个对象添加属性或者方法，但是很难在不改动源代码的基础上给函数添加新的功能。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假如当前我们的代码是这样的</span></span><br><span class="line"> <span class="keyword">const</span> <span class="title function_">a</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line"> &#125;;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 我想添加一个打印2的功能, 这个时候可以直接修改源代码</span></span><br><span class="line"> <span class="keyword">const</span> <span class="title function_">a</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line"> &#125;;     </span><br></pre></td></tr></table></figure>
<p>但是在实际开发中，我们往往接手的是上一个同事留下的代码，鬼知道他在这一段代码里面做了什么。。。。。这个时候可能就要求我们在不改变源代码的基础上给函数增加新的功能。那么我们就可以用到<strong>装饰器</strong>了</p>
<h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><p>在 JavaScript 中，自身并没有原生支持装饰器模式。装饰器模式是一种结构性设计模式，它允许你通过将对象包装在一个或多个装饰器中，以动态地添加或修改对象的行为。<strong>装饰器（Decorator）模式，是一种在运行期动态给某个对象的实例增加功能的方法。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用高阶函数实现装饰器模式</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">withLogging</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Calling function with arguments: <span class="subst">$&#123;args&#125;</span>`</span>);</span><br><span class="line">      <span class="keyword">const</span> result = <span class="title function_">fn</span>(...args);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Function result: <span class="subst">$&#123;result&#125;</span>`</span>);</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> decoratedAdd = <span class="title function_">withLogging</span>(add);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">decoratedAdd</span>(<span class="number">2</span>, <span class="number">3</span>));  <span class="comment">// Output: 5</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用类继承实现装饰器模式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Coffee</span> &#123;</span><br><span class="line">    <span class="title function_">cost</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">MilkDecorator</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Coffee</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">coffee</span>) &#123;</span><br><span class="line">      <span class="variable language_">super</span>();</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_coffee</span> = coffee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">cost</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_coffee</span>.<span class="title function_">cost</span>() + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">SugarDecorator</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Coffee</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">coffee</span>) &#123;</span><br><span class="line">      <span class="variable language_">super</span>();</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_coffee</span> = coffee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">cost</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_coffee</span>.<span class="title function_">cost</span>() + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> coffee = <span class="keyword">new</span> <span class="title class_">Coffee</span>();</span><br><span class="line">  coffee = <span class="keyword">new</span> <span class="title class_">MilkDecorator</span>(coffee);</span><br><span class="line">  coffee = <span class="keyword">new</span> <span class="title class_">SugarDecorator</span>(coffee);</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(coffee.<span class="title function_">cost</span>()); <span class="comment">// Output: 8</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用类成员实现装饰器模式</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">logProperty</span>(<span class="params">target, key, descriptor</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> originalValue = descriptor.<span class="property">value</span>;</span><br><span class="line"></span><br><span class="line">    descriptor.<span class="property">value</span> = <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Calling method <span class="subst">$&#123;key&#125;</span> with arguments: <span class="subst">$&#123;args&#125;</span>`</span>);</span><br><span class="line">      <span class="keyword">const</span> result = originalValue.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Method result: <span class="subst">$&#123;result&#125;</span>`</span>);</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> descriptor;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">MathOperations</span> &#123;</span><br><span class="line">    @logProperty</span><br><span class="line">    <span class="title function_">add</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @logProperty</span><br><span class="line">    <span class="title function_">subtract</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> a - b;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> math = <span class="keyword">new</span> <span class="title class_">MathOperations</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(math.<span class="title function_">add</span>(<span class="number">5</span>, <span class="number">3</span>));</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(math.<span class="title function_">subtract</span>(<span class="number">10</span>, <span class="number">4</span>));</span><br></pre></td></tr></table></figure>



<h2 id="AOP装饰函数的应用"><a href="#AOP装饰函数的应用" class="headerlink" title="AOP装饰函数的应用"></a>AOP装饰函数的应用</h2><p>回到最初的问题，如何在不影响源代码的基础上，给函数添加新的功能</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 利用AOP装饰函数来解决这个问题</span></span><br><span class="line"> <span class="keyword">const</span> <span class="title function_">a</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">addLogProperty</span>(<span class="params">targetFunction</span>) &#123;</span><br><span class="line">    targetFunction.<span class="property">additionalLog</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> targetFunction;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> decoratedA = <span class="title function_">addLogProperty</span>(a);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">decoratedA</span>(); <span class="comment">// Output: 1</span></span><br><span class="line">  decoratedA.<span class="title function_">additionalLog</span>(); <span class="comment">// Output: 2</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>在编写一个函数时，可利用AOP装饰器增加函数的扩展性，可以动态的去为这个函数添加功能，不用去修改源代码。</p>
<p>用AOP装饰函数的技巧在实际开发中非常有用。不管是业务的编写，还是系统框架的设计，都可以把行为按照职责分成粒度更加细粒的函数，随后通过装饰把他们合并到一起。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>JavaScript设计模式与开发实践 <strong>[书籍]</strong></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端架构管理</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript手写代码</title>
    <url>/posts/5b3aed5a/</url>
    <content><![CDATA[<h3 id="1-函数的call-apply-bind"><a href="#1-函数的call-apply-bind" class="headerlink" title="1. 函数的call() &#x2F; apply() &#x2F; bind()"></a>1. 函数的call() &#x2F; apply() &#x2F; bind()</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">自定义函数对象的call方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">call</span> (fn, obj, ...args) &#123;</span><br><span class="line">  <span class="comment">// 如果传入的是null/undefined, this指定为window</span></span><br><span class="line">  <span class="keyword">if</span> (obj===<span class="literal">null</span> || obj===<span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="comment">// obj = window</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">fn</span>(...args)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 给obj添加一个方法: 属性名任意, 属性值必须当前调用call的函数对象</span></span><br><span class="line">  obj.<span class="property">tempFn</span> = fn</span><br><span class="line">  <span class="comment">// 通过obj调用这个方法</span></span><br><span class="line">  <span class="keyword">const</span> result = obj.<span class="title function_">tempFn</span>(...args)</span><br><span class="line">  <span class="comment">// 删除新添加的方法</span></span><br><span class="line">  <span class="keyword">delete</span> obj.<span class="property">tempFn</span></span><br><span class="line">  <span class="comment">// 返回函数调用的结果</span></span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myCall</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> args = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>); <span class="comment">// 获取所有的入参 [&#123; x:10 &#125;, 20, 30]</span></span><br><span class="line">    <span class="keyword">const</span> t = args.<span class="title function_">shift</span>();</span><br><span class="line">    <span class="keyword">if</span> (t === <span class="literal">null</span> || t === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      t = <span class="variable language_">window</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">fn</span>(...args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> self = <span class="variable language_">this</span>; <span class="comment">// 谁调用this就指向谁</span></span><br><span class="line">    t.<span class="property">fn</span> = self;</span><br><span class="line">    <span class="keyword">const</span> res = t.<span class="title function_">fn</span>(...args);</span><br><span class="line">    <span class="keyword">delete</span> t.<span class="property">fn</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a&quot;</span>, a);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;b&quot;</span>, b);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;this&quot;</span>, <span class="variable language_">this</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> res = fn.<span class="title function_">myCall</span>(&#123; <span class="attr">x</span>: <span class="number">10</span> &#125;, <span class="number">20</span>, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">自定义函数对象的apply方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">apply</span> (fn, obj, args) &#123;</span><br><span class="line">  <span class="comment">// 如果传入的是null/undefined, this指定为window</span></span><br><span class="line">  <span class="keyword">if</span> (obj===<span class="literal">null</span> || obj===<span class="literal">undefined</span>) &#123;</span><br><span class="line">    obj = <span class="variable language_">window</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 给obj添加一个方法: 属性名任意, 属性值必须当前调用call的函数对象</span></span><br><span class="line">  obj.<span class="property">tempFn</span> = fn</span><br><span class="line">  <span class="comment">// 通过obj调用这个方法</span></span><br><span class="line">  <span class="keyword">const</span> result = obj.<span class="title function_">tempFn</span>(...args)</span><br><span class="line">  <span class="comment">// 删除新添加的方法</span></span><br><span class="line">  <span class="keyword">delete</span> obj.<span class="property">tempFn</span></span><br><span class="line">  <span class="comment">// 返回函数调用的结果</span></span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">  自定义函数对象的bind方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bind</span> (fn, obj, ...args) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">call</span>(fn, obj, ...args, ...args2)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-函数的节流-throttle-与防抖-debounce"><a href="#2-函数的节流-throttle-与防抖-debounce" class="headerlink" title="2. 函数的节流(throttle)与防抖(debounce)"></a>2. 函数的节流(throttle)与防抖(debounce)</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">用于产生节流函数的工具函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span> (callback, delay) &#123;</span><br><span class="line">  <span class="comment">// 用于保存处理事件的时间, 初始值为0, 保证第一次会执行</span></span><br><span class="line">  <span class="keyword">let</span> start = <span class="number">0</span></span><br><span class="line">  <span class="comment">// 返回事件监听函数 ==&gt; 每次事件发生都会执行</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="comment">// 发生事件的当前时间</span></span><br><span class="line">    <span class="keyword">const</span> current = <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line">    <span class="comment">// 与上一次处理事件的时差大于delay的时间</span></span><br><span class="line">    <span class="keyword">if</span> (current-start&gt;delay) &#123;</span><br><span class="line">      <span class="comment">// 执行处理事件的函数</span></span><br><span class="line">      callback.<span class="title function_">call</span>(event.<span class="property">target</span>, event)</span><br><span class="line">      <span class="comment">// 保证当前时间</span></span><br><span class="line">      start = current</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">用于产生防抖函数的工具函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span> (callback, delay) &#123;</span><br><span class="line">  <span class="comment">// 返回事件监听函数 ==&gt; 每次事件发生都会执行</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果还有未执行的定时器, 清除它</span></span><br><span class="line">    <span class="keyword">if</span> (callback.<span class="property">timeoutId</span>) &#123;</span><br><span class="line">      <span class="built_in">clearTimeout</span>(callback.<span class="property">timeoutId</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 启动延时delay的定时器, 并保证定时器id</span></span><br><span class="line">    callback.<span class="property">timeoutId</span> = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 执行处理事件的函数</span></span><br><span class="line">      callback.<span class="title function_">call</span>(event.<span class="property">target</span>, event)</span><br><span class="line">      <span class="comment">// 删除保存的定时器id</span></span><br><span class="line">      <span class="keyword">delete</span> callback.<span class="property">timeoutId</span></span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-数组去重-unique"><a href="#3-数组去重-unique" class="headerlink" title="3. 数组去重(unique)"></a>3. 数组去重(unique)</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">方法1: 利用forEach()和indexOf()</span></span><br><span class="line"><span class="comment">  双重遍历, 效率差些</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">unique1</span> (array) &#123;</span><br><span class="line">  <span class="keyword">const</span> arr = []</span><br><span class="line">  array.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.<span class="title function_">indexOf</span>(item)===-<span class="number">1</span>) &#123; <span class="comment">// 内部在遍历判断出来的    includes(item)</span></span><br><span class="line">      arr.<span class="title function_">push</span>(item)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">方法2: 利用forEach() + 对象容器</span></span><br><span class="line"><span class="comment">  只需一重遍历, 效率高些</span></span><br><span class="line"><span class="comment">  [1, 3, 5, 3]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">unique2</span> (array) &#123;    </span><br><span class="line">  <span class="keyword">const</span> arr = []</span><br><span class="line">  <span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line">  array.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!obj.<span class="title function_">hasOwnProperty</span>(item)) &#123;<span class="comment">// 不用遍历就能判断出是否已经有了</span></span><br><span class="line">      obj[item] = <span class="literal">true</span></span><br><span class="line">      arr.<span class="title function_">push</span>(item)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">方法3: Array.form + Set</span></span><br><span class="line"><span class="comment">    编码简洁</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">unique3</span> (array) &#123;</span><br><span class="line">  <span class="comment">// return Array.from(new Set(array))</span></span><br><span class="line">  <span class="keyword">return</span> [...<span class="keyword">new</span> <span class="title class_">Set</span>(array)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-数组扁平化-flatten"><a href="#4-数组扁平化-flatten" class="headerlink" title="4. 数组扁平化(flatten)"></a>4. 数组扁平化(flatten)</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">数组扁平化: 取出嵌套数组(多维)中的所有元素放到一个新数组(一维)中</span></span><br><span class="line"><span class="comment">  如: [1, [3, [2, 4]]]  ==&gt;  [1, 3, 2, 4]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">方法一: 递归 + reduce() + concat() + some()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">flatten1</span> (array) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> array.<span class="title function_">reduce</span>(<span class="function">(<span class="params">pre, item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(item) &amp;&amp; item.<span class="title function_">some</span>((<span class="function"><span class="params">cItem</span> =&gt;</span> <span class="title class_">Array</span>.<span class="title function_">isArray</span>(cItem)))) &#123;</span><br><span class="line">      <span class="keyword">return</span> pre.<span class="title function_">concat</span>(<span class="title function_">flatten1</span>(item))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> pre.<span class="title function_">concat</span>(item)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">方法二: ... + some() + concat()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">flatten2</span> (arr) &#123;</span><br><span class="line">  <span class="comment">// 只要arr是一个多维数组(有元素是数组)</span></span><br><span class="line">  <span class="keyword">while</span> (arr.<span class="title function_">some</span>(<span class="function"><span class="params">item</span> =&gt;</span> <span class="title class_">Array</span>.<span class="title function_">isArray</span>(item))) &#123;</span><br><span class="line">    <span class="comment">// 对arr进行降维</span></span><br><span class="line">    arr = [].<span class="title function_">concat</span>(...arr)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">方法三: ... + some() + concat()</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="keyword">var</span> arr = [</span><br><span class="line">        [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>],</span><br><span class="line">        [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>],</span><br><span class="line">        [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>],</span><br><span class="line">        [<span class="number">11</span>, <span class="number">12</span>, [<span class="number">12</span>, <span class="number">12</span>, [<span class="number">13</span>]]],</span><br><span class="line">        <span class="number">10</span>,</span><br><span class="line">      ];</span><br><span class="line">      <span class="comment">// 数组扁平化</span></span><br><span class="line">      <span class="comment">// 去重</span></span><br><span class="line">      <span class="comment">// 排序</span></span><br><span class="line">      <span class="comment">// 不能使用箭头函数（this会指向window）</span></span><br><span class="line">      <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">flat</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> result = <span class="variable language_">this</span>.<span class="title function_">map</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(item)) &#123;</span><br><span class="line">            <span class="keyword">return</span> item.<span class="title function_">flat</span>();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> [item];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> [].<span class="title function_">concat</span>(...result);</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="comment">// 去重</span></span><br><span class="line">      <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">unique</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> [...<span class="keyword">new</span> <span class="title class_">Set</span>(<span class="variable language_">this</span>)];</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="comment">// 排序</span></span><br><span class="line">      <span class="keyword">const</span> <span class="title function_">sortFn</span> = (<span class="params">a, b</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> a - b;</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="keyword">const</span> a = arr.<span class="title function_">flat</span>().<span class="title function_">unique</span>().<span class="title function_">sort</span>(sortFn);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="5-深拷贝"><a href="#5-深拷贝" class="headerlink" title="5. 深拷贝"></a>5. 深拷贝</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">深度克隆</span></span><br><span class="line"><span class="comment">1). 大众乞丐版</span></span><br><span class="line"><span class="comment">    问题1: 函数属性会丢失</span></span><br><span class="line"><span class="comment">    问题2: 循环引用会出错</span></span><br><span class="line"><span class="comment">2). 面试基础版本</span></span><br><span class="line"><span class="comment">    解决问题1: 函数属性还没丢失</span></span><br><span class="line"><span class="comment">3). 面试加强版本</span></span><br><span class="line"><span class="comment">    解决问题2: 循环引用正常</span></span><br><span class="line"><span class="comment">4). 面试加强版本2(优化遍历性能)</span></span><br><span class="line"><span class="comment">    数组: while | for | forEach() 优于 for-in | keys()&amp;forEach() </span></span><br><span class="line"><span class="comment">    对象: for-in 与 keys()&amp;forEach() 差不多</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    cloneDeep()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: &#123;</span><br><span class="line">       <span class="attr">m</span>: <span class="number">1</span> </span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">b</span>: [<span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">    <span class="attr">fn</span>: <span class="keyword">function</span> (<span class="params"></span>)&#123;&#125;,</span><br><span class="line">    <span class="attr">d</span>: <span class="string">&#x27;abc&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">obj.<span class="property">a</span>.<span class="property">c</span> = obj.<span class="property">b</span></span><br><span class="line">obj.<span class="property">b</span>[<span class="number">2</span>] = obj.<span class="property">a</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">1). 大众乞丐版</span></span><br><span class="line"><span class="comment">  问题1: 函数属性会丢失</span></span><br><span class="line"><span class="comment">  问题2: 循环引用会出错</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">deepClone1</span>(<span class="params">target</span>) &#123; <span class="comment">// 从后台获取的数据都可以用</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(target))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">获取数据的类型字符串名</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getType</span>(<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(data).<span class="title function_">slice</span>(<span class="number">8</span>, -<span class="number">1</span>)  <span class="comment">// -1代表最后一位</span></span><br><span class="line">    <span class="comment">// [object Array]  ===&gt; Array  [object Object] ==&gt; Object</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2). 面试基础版本</span></span><br><span class="line"><span class="comment">  解决问题1: 函数属性还没丢失</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">deepClone2</span>(<span class="params">target</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> type = <span class="title function_">getType</span>(target)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (type===<span class="string">&#x27;Object&#x27;</span> || type===<span class="string">&#x27;Array&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> cloneTarget = type === <span class="string">&#x27;Array&#x27;</span> ? [] : &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> target) &#123;</span><br><span class="line">      <span class="keyword">if</span> (target.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">        cloneTarget[key] = <span class="title function_">deepClone2</span>(target[key])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cloneTarget</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">3). 面试加强版本</span></span><br><span class="line"><span class="comment">  解决问题2: 循环引用正常</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">deepClone3</span>(<span class="params">target, map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> type = <span class="title function_">getType</span>(target)</span><br><span class="line">  <span class="keyword">if</span> (type===<span class="string">&#x27;Object&#x27;</span> || type===<span class="string">&#x27;Array&#x27;</span>) &#123;</span><br><span class="line">     <span class="comment">// 从map容器取对应的clone对象</span></span><br><span class="line">    <span class="keyword">let</span> cloneTarget = map.<span class="title function_">get</span>(target)</span><br><span class="line">    <span class="comment">// 如果有, 直接返回这个clone对象</span></span><br><span class="line">    <span class="keyword">if</span> (cloneTarget) &#123;</span><br><span class="line">      <span class="keyword">return</span> cloneTarget</span><br><span class="line">    &#125;</span><br><span class="line">    cloneTarget = type===<span class="string">&#x27;Array&#x27;</span> ? [] : &#123;&#125;</span><br><span class="line">    <span class="comment">// 将clone产生的对象保存到map容器</span></span><br><span class="line">    map.<span class="title function_">set</span>(target, cloneTarget)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> target) &#123;</span><br><span class="line">      <span class="keyword">if</span> (target.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">        cloneTarget[key] = <span class="title function_">deepClone3</span>(target[key], map)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cloneTarget</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">4). 面试加强版本2(优化遍历性能)</span></span><br><span class="line"><span class="comment">    数组: while | for | forEach() 优于 for-in | keys()&amp;forEach() </span></span><br><span class="line"><span class="comment">    对象: for-in 与 keys()&amp;forEach() 差不多</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">deepClone4</span>(<span class="params">target, map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> type = <span class="title function_">getType</span>(target)</span><br><span class="line">  <span class="keyword">if</span> (type===<span class="string">&#x27;Object&#x27;</span> || type===<span class="string">&#x27;Array&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 判断是否拷贝完成</span></span><br><span class="line">    <span class="keyword">let</span> cloneTarget = map.<span class="title function_">get</span>(target)</span><br><span class="line">    <span class="keyword">if</span> (cloneTarget) &#123;</span><br><span class="line">      <span class="keyword">return</span> cloneTarget</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (type===<span class="string">&#x27;Array&#x27;</span>) &#123;</span><br><span class="line">      cloneTarget = []</span><br><span class="line">      map.<span class="title function_">set</span>(target, cloneTarget)</span><br><span class="line">      target.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">        cloneTarget[index] = <span class="title function_">deepClone4</span>(item, map)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      cloneTarget = &#123;&#125;</span><br><span class="line">      map.<span class="title function_">set</span>(target, cloneTarget)</span><br><span class="line">      <span class="title class_">Object</span>.<span class="title function_">keys</span>(target).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">        cloneTarget[key] = <span class="title function_">deepClone4</span>(target[key], map)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cloneTarget</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-自定义new和instanceof工具函数"><a href="#6-自定义new和instanceof工具函数" class="headerlink" title="6. 自定义new和instanceof工具函数"></a>6. 自定义new和instanceof工具函数</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">自定义new工具函数</span></span><br><span class="line"><span class="comment">  语法: newInstance(Fn, ...args)</span></span><br><span class="line"><span class="comment">  功能: 创建Fn构造函数的实例对象</span></span><br><span class="line"><span class="comment">  实现: 创建空对象obj, 调用Fn指定this为obj, 返回obj</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">newInstance</span>(<span class="params">Fn, ...args</span>) &#123;</span><br><span class="line">  <span class="comment">// 创建一个新的对象</span></span><br><span class="line">  <span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line">  <span class="comment">// 执行构造函数</span></span><br><span class="line">  <span class="keyword">const</span> result = <span class="title class_">Fn</span>.<span class="title function_">apply</span>(obj, args) <span class="comment">// 相当于: obj.Fn()</span></span><br><span class="line">  <span class="comment">// 如果构造函数执行的结果是对象, 返回这个对象</span></span><br><span class="line">  <span class="keyword">if</span> (result <span class="keyword">instanceof</span> <span class="title class_">Object</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 给obj指定__proto__为Fn的prototype</span></span><br><span class="line">  obj.<span class="property">__proto__</span> = <span class="title class_">Fn</span>.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line">  <span class="comment">// 如果不是, 返回新创建的对象</span></span><br><span class="line">  <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Fn</span> () &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;tom&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> []</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Fn</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">自定义instanceof工具函数: </span></span><br><span class="line"><span class="comment">  语法: myInstanceOf(obj, Type)</span></span><br><span class="line"><span class="comment">  功能: 判断obj是否是Type类型的实例</span></span><br><span class="line"><span class="comment">  实现: Type的原型对象是否是obj的原型链上的某个对象, 如果是返回true, 否则返回false</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myInstanceOf</span>(<span class="params">obj, Type</span>) &#123;</span><br><span class="line">  <span class="comment">// 得到原型对象</span></span><br><span class="line">  <span class="keyword">let</span> protoObj = obj.<span class="property">__proto__</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 只要原型对象存在</span></span><br><span class="line">  <span class="keyword">while</span>(protoObj) &#123;</span><br><span class="line">    <span class="comment">// 如果原型对象是Type的原型对象, 返回true</span></span><br><span class="line">    <span class="keyword">if</span> (protoObj === <span class="title class_">Type</span>.<span class="property"><span class="keyword">prototype</span></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 指定原型对象的原型对象</span></span><br><span class="line">    protoObj = protoObj.<span class="property">__proto__</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-字符串处理"><a href="#7-字符串处理" class="headerlink" title="7. 字符串处理"></a>7. 字符串处理</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">1. 字符串倒序: reverseString(str)  生成一个倒序的字符串</span></span><br><span class="line"><span class="comment">2. 字符串是否是回文: palindrome(str) 如果给定的字符串是回文，则返回 true ；否则返回 false</span></span><br><span class="line"><span class="comment">3. 截取字符串: truncate(str, num) 如果字符串的长度超过了num, 截取前面num长度部分, 并以...结束</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">1. 字符串倒序: reverseString(str)  生成一个倒序的字符串</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reverseString</span>(<span class="params">str</span>) &#123;  <span class="comment">// abc</span></span><br><span class="line">  <span class="comment">// return str.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;)</span></span><br><span class="line">  <span class="comment">// return [...str].reverse().join(&#x27;&#x27;)</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(str).<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">2. 字符串是否是回文: palindrome(str) 如果给定的字符串是回文，则返回 true ；否则返回 false</span></span><br><span class="line"><span class="comment">    abcba  abccba</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">palindrome</span>(<span class="params">str</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> str === <span class="title function_">reverseString</span>(str)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">3. 截取字符串: truncate(str, num) 如果字符串的长度超过了num, 截取前面num长度部分, 并以...结束</span></span><br><span class="line"><span class="comment">abcde...</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">truncate</span>(<span class="params">str, num</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> str.<span class="property">length</span> &gt; num ? str.<span class="title function_">slice</span>(<span class="number">0</span>, num) + <span class="string">&#x27;...&#x27;</span> : str</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">abcdd...</span><br></pre></td></tr></table></figure>
<h3 id="8-简单排序-冒泡-选择-插入"><a href="#8-简单排序-冒泡-选择-插入" class="headerlink" title="8. 简单排序: 冒泡 &#x2F; 选择 &#x2F; 插入"></a>8. 简单排序: 冒泡 &#x2F; 选择 &#x2F; 插入</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">冒泡排序的方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bubbleSort</span> (array) &#123;</span><br><span class="line">  <span class="comment">// 1.获取数组的长度</span></span><br><span class="line">  <span class="keyword">var</span> length = array.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.反向循环, 因此次数越来越少</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="comment">// 3.根据i的次数, 比较循环到i位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">      <span class="comment">// 4.如果j位置比j+1位置的数据大, 那么就交换</span></span><br><span class="line">      <span class="keyword">if</span> (array[j] &gt; array[j + <span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="comment">// 交换</span></span><br><span class="line">        <span class="comment">// const temp = array[j+1]</span></span><br><span class="line">        <span class="comment">// array[j+1] = array[j]</span></span><br><span class="line">        <span class="comment">// array[j] = temp</span></span><br><span class="line">        [array[j + <span class="number">1</span>], array[j]] = [array[j], array[j + <span class="number">1</span>]];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">选择排序的方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">selectSort</span> (array) &#123;</span><br><span class="line">  <span class="comment">// 1.获取数组的长度</span></span><br><span class="line">  <span class="keyword">var</span> length = array.<span class="property">length</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.外层循环: 从0位置开始取出数据, 直到length-2位置</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 3.内层循环: 从i+1位置开始, 和后面的内容比较</span></span><br><span class="line">    <span class="keyword">var</span> min = i</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = min + <span class="number">1</span>; j &lt; length; j++) &#123;</span><br><span class="line">      <span class="comment">// 4.如果i位置的数据大于j位置的数据, 记录最小的位置</span></span><br><span class="line">      <span class="keyword">if</span> (array[min] &gt; array[j]) &#123;</span><br><span class="line">        min = j</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (min !== i) &#123;</span><br><span class="line">      <span class="comment">// 交换</span></span><br><span class="line">      [array[min], array[i]] = [array[i], array[min]];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">插入排序的方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">insertSort</span> (array) &#123;</span><br><span class="line">  <span class="comment">// 1.获取数组的长度</span></span><br><span class="line">  <span class="keyword">var</span> length = array.<span class="property">length</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.外层循环: 外层循环是从1位置开始, 依次遍历到最后</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="comment">// 3.记录选出的元素, 放在变量temp中</span></span><br><span class="line">    <span class="keyword">var</span> j = i</span><br><span class="line">    <span class="keyword">var</span> temp = array[i]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.内层循环: 内层循环不确定循环的次数, 最好使用while循环</span></span><br><span class="line">    <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; array[j - <span class="number">1</span>] &gt; temp) &#123;</span><br><span class="line">      array[j] = array[j - <span class="number">1</span>]</span><br><span class="line">      j--</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.将选出的j位置, 放入temp元素</span></span><br><span class="line">    array[j] = temp</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> array</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">products.<span class="title function_">sort</span>(<span class="function">(<span class="params">item1, item2</span>) =&gt;</span> &#123;  </span><br><span class="line">    <span class="comment">// 返回正数, item2在右边, 返回负数, item1在右边, 返回0为原本顺序</span></span><br><span class="line">    <span class="keyword">return</span> item1.<span class="property">price</span> - item2.<span class="property">price</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="9、继承"><a href="#9、继承" class="headerlink" title="9、继承"></a>9、继承</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//封装一个父类</span></span><br><span class="line">       <span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age, sex</span>) &#123;</span><br><span class="line">           <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">           <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">           <span class="variable language_">this</span>.<span class="property">sex</span> = sex;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">eat</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">           <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;螺蛳粉&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="comment">//封装一个子类</span></span><br><span class="line">       <span class="keyword">function</span> <span class="title function_">Student</span>(<span class="params">classRoom, score, name, age, sex</span>) &#123;</span><br><span class="line">           <span class="variable language_">this</span>.<span class="property">classRoom</span> = classRoom;</span><br><span class="line">           <span class="variable language_">this</span>.<span class="property">score</span> = score;</span><br><span class="line">           <span class="comment">//构造函数继承调用父类，并把父类的this指向自己的this</span></span><br><span class="line">           <span class="title class_">Person</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name, age, sex)</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//以下方法缺点：1.eat共享了  2.如果继承多个属性或方法 需要一个个添加</span></span><br><span class="line">       <span class="comment">// Student.prototype.eat = Person.prototype.eat;</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//以下方法的缺点：1.赋值是地址的赋值，子类和父类的原型对象共享了  2.构造器属性也是不对的</span></span><br><span class="line">       <span class="comment">// Student.prototype = Person.prototype;</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//原型对象继承:把父类的实例化对象 当做自己的原型对象</span></span><br><span class="line">       <span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Person</span>;</span><br><span class="line">       <span class="comment">//修正构造器属性(添加constructor属性)</span></span><br><span class="line">       <span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Student</span>;</span><br><span class="line">       <span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">study</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">           <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;面向对象&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="keyword">var</span> s1 = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">405</span>, <span class="number">100</span>, <span class="string">&quot;张三&quot;</span>, <span class="number">18</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(s1);</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(s1.<span class="property">eat</span>);</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(s1.<span class="property">study</span>);</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(s1.<span class="property">constructor</span>);</span><br></pre></td></tr></table></figure>
<h3 id="10、js调度器（并发编程）"><a href="#10、js调度器（并发编程）" class="headerlink" title="10、js调度器（并发编程）"></a>10、js调度器（并发编程）</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Scheduler</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">max</span>) &#123;</span><br><span class="line">    <span class="comment">// 最大可并发任务数</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">max</span> = max;</span><br><span class="line">    <span class="comment">// 当前并发任务数</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">count</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 阻塞的任务队列</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">queue</span> = [];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">add</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">count</span> &gt;= <span class="variable language_">this</span>.<span class="property">max</span>) &#123;</span><br><span class="line">      <span class="comment">// 若当前正在执行的任务，达到最大容量max</span></span><br><span class="line">      <span class="comment">// 阻塞在此处，等待前面的任务执行完毕后将resolve弹出并执行</span></span><br><span class="line">      <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="title function_">push</span>(resolve));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前并发任务数++</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">count</span>++;</span><br><span class="line">    <span class="comment">// 使用await执行此函数</span></span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">fn</span>();</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">0</span></span><br><span class="line">    a++</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res, a)</span><br><span class="line">    <span class="comment">// 执行完毕，当前并发任务数--</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">count</span>--;</span><br><span class="line">    <span class="comment">// 若队列中有值，将其resolve弹出，并执行</span></span><br><span class="line">    <span class="comment">// 以便阻塞的任务，可以正常执行</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="property">length</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="title function_">shift</span>()();</span><br><span class="line">    <span class="comment">// 返回函数执行的结果</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">sleep</span> = (<span class="params">time</span>) =&gt;</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, time);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> scheduler = <span class="keyword">new</span> <span class="title class_">Scheduler</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">addTask</span> = (<span class="params">time, val</span>) =&gt; &#123;</span><br><span class="line">  scheduler.<span class="title function_">add</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">sleep</span>(time).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(val);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">addTask</span>(<span class="number">1000</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">  <span class="title function_">addTask</span>(<span class="number">200</span>, <span class="string">&quot;5&quot;</span>);</span><br><span class="line">  <span class="title function_">addTask</span>(<span class="number">500</span>, <span class="string">&quot;2&quot;</span>);</span><br><span class="line">  <span class="title function_">addTask</span>(<span class="number">300</span>, <span class="string">&quot;3&quot;</span>);</span><br><span class="line">  <span class="title function_">addTask</span>(<span class="number">400</span>, <span class="string">&quot;4&quot;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="11、手写async和await"><a href="#11、手写async和await" class="headerlink" title="11、手写async和await"></a>11、手写async和await</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// generator函数</span></span><br><span class="line"><span class="comment">// async、await的特征是能暂停执行并能恢复执行</span></span><br><span class="line"><span class="comment">// generator的特征也是如此  </span></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span> <span class="comment">// yield用来暂停执行</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span> <span class="comment">// next（）方法来恢复执行</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> g = <span class="title function_">gen</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>())	<span class="comment">// &#123;value: 1, done: false&#125; value是返回的值，done是generator函数是否已经走完</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>())	<span class="comment">// &#123;value: 2, done: false&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>())	<span class="comment">// &#123;value: 3, done: false&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>())	<span class="comment">// &#123;value: 4, done: false&#125;  // 最终的返回值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">sixuetang</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> data1 = <span class="keyword">await</span> <span class="title function_">getData</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">const</span> data2 = <span class="keyword">await</span> <span class="title function_">getData</span>(data1);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`success: <span class="subst">$&#123;data2&#125;</span>`</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">function</span>* <span class="title function_">sixuetang</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> data1 = <span class="keyword">yield</span> <span class="title function_">getData</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">const</span> data2 = <span class="keyword">yield</span> <span class="title function_">getData</span>(data1);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`success: <span class="subst">$&#123;data2&#125;</span>`</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> g = <span class="title function_">sixuetang</span>();</span><br><span class="line">      <span class="keyword">const</span> next1 = g.<span class="title function_">next</span>(); <span class="comment">// &#123;value: Promise&#123;&lt;fulfilled&gt;&#125;, done: false&#125;</span></span><br><span class="line"></span><br><span class="line">      next1.<span class="property">value</span>.<span class="title function_">then</span>(<span class="function">(<span class="params">data1</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;data1: &quot;</span>, data1);</span><br><span class="line">        <span class="keyword">const</span> next2 = g.<span class="title function_">next</span>(data1);</span><br><span class="line">        next2.<span class="property">value</span>.<span class="title function_">then</span>(<span class="function">(<span class="params">data2</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;data2: &quot;</span>, data2);</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>(data2));</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">	<span class="comment">// 封装一个适用性更强</span></span><br><span class="line">      <span class="keyword">function</span> <span class="title function_">generatorToAsync</span>(<span class="params">generatorFun</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> g = <span class="title function_">generatorFun</span>();</span><br><span class="line">            <span class="keyword">const</span> next1 = g.<span class="title function_">next</span>();</span><br><span class="line">            next1.<span class="property">value</span>.<span class="title function_">then</span>(<span class="function">(<span class="params">data1</span>) =&gt;</span> &#123;</span><br><span class="line">              <span class="keyword">const</span> next2 = g.<span class="title function_">next</span>(data1);</span><br><span class="line">              next2.<span class="property">value</span>.<span class="title function_">then</span>(<span class="function">(<span class="params">data2</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="title function_">resolve</span>(g.<span class="title function_">next</span>(data2).<span class="property">value</span>);</span><br><span class="line">              &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">function</span> <span class="title function_">generatorToAsync</span>(<span class="params">generatorFun</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">          <span class="keyword">const</span> gen = generatorFun.<span class="title function_">apply</span>(<span class="variable language_">this</span>.<span class="property">arguments</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">function</span> <span class="title function_">step</span>(<span class="params">key, arg</span>) &#123;</span><br><span class="line">              <span class="keyword">let</span> res;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                res = gen[key](arg);</span><br><span class="line">              &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="title function_">reject</span>(error);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">const</span> &#123; value, done &#125; = res;</span><br><span class="line">              <span class="keyword">if</span> (done) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="title function_">resolve</span>(value);</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(value).<span class="title function_">then</span>(</span><br><span class="line">                  <span class="function">(<span class="params">val</span>) =&gt;</span> <span class="title function_">step</span>(<span class="string">&quot;next&quot;</span>, val),</span><br><span class="line">                  <span class="function">(<span class="params">err</span>) =&gt;</span> <span class="title function_">step</span>(<span class="string">&quot;throw&quot;</span>, err)</span><br><span class="line">                );</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="title function_">step</span>(<span class="string">&quot;next&quot;</span>);</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> asyncFn = <span class="title function_">generatorToAsync</span>(sixuetang);</span><br><span class="line">      <span class="title function_">asyncFn</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(res));</span><br></pre></td></tr></table></figure>
<h3 id="12、函数柯里化"><a href="#12、函数柯里化" class="headerlink" title="12、函数柯里化"></a>12、函数柯里化</h3><h4 id="精简版柯里化"><a href="#精简版柯里化" class="headerlink" title="精简版柯里化"></a>精简版柯里化</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">curring</span> = (<span class="params">protocol</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">hostname, pathname</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;protocol&#125;</span><span class="subst">$&#123;hostname&#125;</span><span class="subst">$&#123;pathname&#125;</span>`</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> https = <span class="title function_">curring</span>(<span class="string">&quot;https://&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> uri = <span class="title function_">https</span>(<span class="string">&#x27;www.baidu.com&#x27;</span>, <span class="string">&#x27;/picture&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(uri) <span class="comment">// https://www.baidu.com/picture</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、如何通过数组解耦获取属性值</span></span><br><span class="line"><span class="keyword">const</span> list = [</span><br><span class="line">  &#123;<span class="attr">mid</span>:<span class="string">&#x27;123&#x27;</span>, <span class="attr">per</span>:<span class="string">&#x27;123&#x27;</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">mid</span>: <span class="string">&#x27;qqq&#x27;</span>, <span class="attr">per</span>: <span class="string">&#x27;2222&#x27;</span>&#125;</span><br><span class="line">]</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">curring</span> = key =&gt; <span class="function"><span class="params">item</span> =&gt;</span> item[key]</span><br><span class="line"><span class="keyword">const</span> mid = <span class="title function_">curring</span>(<span class="string">&#x27;mid&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> per = <span class="title function_">curring</span>(<span class="string">&#x27;per&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(list.<span class="title function_">map</span>(mid))    <span class="comment">// [ &#x27;123&#x27;, &#x27;qqq&#x27; ]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(list.<span class="title function_">map</span>(per))    <span class="comment">// [ &#x27;123&#x27;, &#x27;2222&#x27; ]</span></span><br></pre></td></tr></table></figure>

<h4 id="柯里化-隐式调用"><a href="#柯里化-隐式调用" class="headerlink" title="柯里化 (隐式调用)"></a>柯里化 (隐式调用)</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">num</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(...args) <span class="comment">// 1 2 3·</span></span><br><span class="line">  <span class="keyword">return</span> args</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">num</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此方法无法无限输入参数链式调用</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a</span>) &#123;</span><br><span class="line">  <span class="comment">// arguments是一个类数组对象，</span></span><br><span class="line">  <span class="comment">// 可通过Array.prototype.slice.call 转换成数组</span></span><br><span class="line">  <span class="comment">// Array.prototype.slice.call(arguments)能将具有length属性的对象转成数组</span></span><br><span class="line">  <span class="keyword">let</span> args = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">  <span class="keyword">let</span> inner = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    args.<span class="title function_">push</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line">    <span class="keyword">let</span> sum = args.<span class="title function_">reduce</span>(<span class="keyword">function</span> (<span class="params">perv, cur</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> prev + cur</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> inner</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add</span>(<span class="number">1</span>)(<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过修改toString 隐式调用来达到柯里化的目的，但是输出的是一个函数类型</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a</span>) &#123;</span><br><span class="line">  <span class="comment">// arguments是一个类数组对象，</span></span><br><span class="line">  <span class="comment">// 可通过Array.prototype.slice.call 转换成数组</span></span><br><span class="line">  <span class="comment">// Array.prototype.slice.call(arguments)能将具有length属性的对象转成数组</span></span><br><span class="line">  <span class="keyword">let</span> args = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">  <span class="keyword">let</span> inner = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    args.<span class="title function_">push</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line">  &#125;</span><br><span class="line">  inner.<span class="property">toString</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> args.<span class="title function_">reduce</span>(<span class="keyword">function</span> (<span class="params">prev, cur</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> prev + cur</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> inner</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">curring</span> = (<span class="params">func</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> args = [];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">result</span>(<span class="params">...rest</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(rest.<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">func</span>(...args)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            args.<span class="title function_">push</span>(...rest);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<h4 id="定制柯里化"><a href="#定制柯里化" class="headerlink" title="定制柯里化"></a>定制柯里化</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 求和函数</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">sumFn</span> = (<span class="params">...args</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> args.<span class="title function_">reduce</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 对参数进行排序</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">sortFn</span> = (<span class="params">...args</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> args.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    a - b;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">curring</span> = (<span class="params">func</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> args = [];</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">result</span>(<span class="params">...rest</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (rest.<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">func</span>(...args);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      args.<span class="title function_">push</span>(...rest);</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">curring</span>(sumFn)(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)(<span class="number">6</span>)() )  <span class="comment">// 21</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">curring</span>(sortFn)(<span class="number">1</span>)(<span class="number">3</span>)(<span class="number">2</span>)(<span class="number">5</span>, <span class="number">4</span>)() )    <span class="comment">//  [1,2,3,4,5]</span></span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.bilibili.com/video/BV1XZ4y1y7BX/?spm_id_from=333.337.search-card.all.click&vd_source=ad69edc9a457e7180dde2d7baf02ad26">JS每日一题：如何设计一个任务队列？控制请求最大并发数</a></li>
<li><a href="https://www.bilibili.com/video/BV1yS4y1C786/?spm_id_from=333.337.search-card.all.click&vd_source=ad69edc9a457e7180dde2d7baf02ad26">JS每日一题：一道编程题来了解函数柯里化的妙用</a></li>
<li><a href="https://www.bilibili.com/video/BV13a41187yp/?spm_id_from=333.337.search-card.all.click&vd_source=ad69edc9a457e7180dde2d7baf02ad26">手写async</a></li>
<li><a href="https://juejin.cn/post/6844904052237713422">初、中级前端应该要掌握的手写代码实现</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端面试</tag>
      </tags>
  </entry>
  <entry>
    <title>文章分类模板</title>
    <url>/posts/401e296e/</url>
    <content><![CDATA[<h2 id="初始化项目分类及标签"><a href="#初始化项目分类及标签" class="headerlink" title="初始化项目分类及标签"></a>初始化项目分类及标签</h2><p>tags: </p>
<ul>
<li>前端面试</li>
<li>前端架构管理</li>
<li>前端监控</li>
<li>前端性能优化</li>
<li>前端源码解析</li>
<li>前端项目管理</li>
</ul>
<p>categories: </p>
<ul>
<li>前端</li>
<li>后端</li>
<li>计算机基础</li>
</ul>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>前端架构管理</tag>
        <tag>前端面试</tag>
        <tag>前端性能优化</tag>
        <tag>前端源码解析</tag>
        <tag>前端项目管理</tag>
        <tag>前端监控</tag>
      </tags>
  </entry>
  <entry>
    <title>写了个辅助学习vite的小工具</title>
    <url>/posts/5862c0a6/</url>
    <content><![CDATA[<h2 id="仓库地址-mini-vite"><a href="#仓库地址-mini-vite" class="headerlink" title="仓库地址 mini-vite"></a>仓库地址 <a href="https://github.com/lyk990/mini-vite">mini-vite</a></h2><h2 id="文章链接"><a href="#文章链接" class="headerlink" title="文章链接"></a><a href="https://juejin.cn/post/7239173192493514808">文章链接</a></h2>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端项目管理</tag>
      </tags>
  </entry>
  <entry>
    <title>深圳前端一年半，投了两个月简历，第一场面试</title>
    <url>/posts/2a476d98/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><blockquote>
<p>base深圳，一年半经验，找的初级前端岗位，1-3年，投简历两个月只有两个面试，这是第一个面试</p>
</blockquote>
<h2 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h2><h3 id="你对html元素是怎么分类的？"><a href="#你对html元素是怎么分类的？" class="headerlink" title="你对html元素是怎么分类的？"></a>你对html元素是怎么分类的？</h3><p>一开始我愣了一下？搞这么简单的问题？？？后面又问面试官你是指的id选择器这些吗，，还是display：block,inline-block这些？不管了，反正我全都讲了一遍，说了下这些八股文基础，感觉有点简单，说得有点少。另外又展开说了HTML DOM节点那些内容</p>
<p><strong>image是行内元素为什么有宽高？</strong></p>
<p>这个问题我倒是没有了解过啊，想了下说，会不会和input或者什么video之类的差不多，对于这类元素，浏览器有其他的解析方式（万能答法：问什么都能答<strong>浏览器解析</strong>）</p>
<p>面试官让我了解下可替换元素，，img属于<strong>可替换元素</strong></p>
<h3 id="你用过哪些http状态码？"><a href="#你用过哪些http状态码？" class="headerlink" title="你用过哪些http状态码？"></a>你用过哪些http状态码？</h3><p>因为没有刻意的去背这些玩意，所以只是大概做了下分类。就回答了常见的状态码，比如101我就在websocket上见过，200或者201就是请求成功，3开头大概就是重定向的，又展开说了下永久重定向和临时重定向的区别，4开头的大概就是前端问题，比如401就是没有权限没有token，404请求url错误，5开头的大概就是后端问题，只说了自己见过的一些状态码</p>
<p><strong>404就一定是前端问题吗？</strong></p>
<p>不一定，状态码是可以修改的，比如接口抛错我也可以搞个404，前后端联调可以协商的</p>
<h3 id="说下强缓存和协商缓存"><a href="#说下强缓存和协商缓存" class="headerlink" title="说下强缓存和协商缓存"></a>说下强缓存和协商缓存</h3><p>搞忘记是请求头的哪个字段了，几个月都没看过http方面的内容了，好像是cache-control,只记得一个no-store，这个是不缓存，简单讲了下强缓存和协商缓存的区别，强缓存就是直接从缓存中拿取数据，不用再发请求，会有一个过期时间来判断是否命中，协商缓存通过Last-Modified（文件上次修改时间）和etag（文件内容是否变化）来命中。</p>
<p>接着又展开讲了下磁盘缓存（disk cache）和内存缓存（memory cache）的区别，从读取速度，缓存资源大小展开讲了下</p>
<p>突然想到了vite，最近在学习vite，就又讲了下vite的<strong>分包</strong>处理，vite用到的<strong>强缓存</strong>和<strong>协商缓存</strong></p>
<h3 id="说下js异步"><a href="#说下js异步" class="headerlink" title="说下js异步"></a>说下js异步</h3><p>除了常见的八股文回答知识</p>
<p>我又提到了async和await，<strong>async和await的内部实现</strong>，是怎么通过generator，yield，next()来实现的</p>
<p>还讲了下<strong>不同的执行环境，js的执行机制也会有区别</strong>，在node环境和浏览器环境js异步执行的区别。</p>
<h3 id="说下es6的新特性"><a href="#说下es6的新特性" class="headerlink" title="说下es6的新特性"></a>说下es6的新特性</h3><p>let const、map、set，,weakmap,weakset,解构，简单提了下，在vue3源码中用到的weakmap，准备说下内存泄漏的，，但是这玩意太难了，想了想还是没说了，就说了这几个、跟面试官说还有一些语法，但是不知道怎么描述，别的突然一下子想不起来了</p>
<h3 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h3><p>我还以为要我手写，我直接回答，这玩意手写我不会，我都是直接引入lodash的，什么手写call、apply、bind这些，我都不会，结果面试官不要我手写，，是我太敏感了（主要是对这种手写代码太厌恶了）</p>
<p>按照八股文面试题简单讲了下区别，主要就是<strong>堆栈中地址值的传递</strong></p>
<p>接着又展开讲到了<strong>内存、cpu、进程、堆和栈</strong>。堆和栈是放在进程中的，而进程又会被装入内存中，栈和堆本质上都只是内存中的一片区域，编写的一行行代码都会被转成指令，保存到内存中，cpu就是从内存中获取指令并执行。这些太久没学了记不太清，不敢说得太多，就简单说了下</p>
<h3 id="打包之后哪些文件会被解析成ventor文件"><a href="#打包之后哪些文件会被解析成ventor文件" class="headerlink" title="打包之后哪些文件会被解析成ventor文件"></a>打包之后哪些文件会被解析成ventor文件</h3><p>其实我也不太了解，说了个node_modules也不知道对不对，然后就简单讲了下vite分包，，怎么做分包</p>
<h3 id="vite预构建依赖是怎么做的"><a href="#vite预构建依赖是怎么做的" class="headerlink" title="vite预构建依赖是怎么做的"></a>vite预构建依赖是怎么做的</h3><p>当时正在写<a href="https://github.com/lyk990/mini-vite">mini-vite</a>，面试官看我老是提vite，可能就随便问了下，主要就是计算出入口文件，通过esbuild进行依赖扫描，然后将其打包放在指定得文件夹内，会根据打包的内容生成一个hash值，内容改变hash值也会改变，保存在一个json文件中，每次开启项目时都会对比这个hash值来判断是否需要重新预构建依赖</p>
<h3 id="vue的数组为什么不能做响应式"><a href="#vue的数组为什么不能做响应式" class="headerlink" title="vue的数组为什么不能做响应式"></a>vue的数组为什么不能做响应式</h3><p>没看vue2的源码，好像是读取不到数组的长度（可能回答的是错误的），直接跟面试官说不太了解vue2的源码，平常都是看的vue3源码，但是还是强行扯了两句，用vue2响应式跟vue3做了对比，扯到了<strong>vue3响应式</strong>，<strong>收集依赖和触发依赖</strong>。然后提到了，proxy、reflect，又说了一下这个es6的新特性，在vue3中的源码是怎么用的。</p>
<h3 id="你有移动端项目，，肯定做了适配吧，，怎么做的适配？"><a href="#你有移动端项目，，肯定做了适配吧，，怎么做的适配？" class="headerlink" title="你有移动端项目，，肯定做了适配吧，，怎么做的适配？"></a>你有移动端项目，，肯定做了适配吧，，怎么做的适配？</h3><p>我笑了，不好意思，还真没做适配，移动端项目主要是给我们公司内部使用，所以移动端都是固定的屏幕大小，用不到适配。</p>
<p>不过我大学毕业设计的项目用过，用的淘宝适配方案，主要就是改变根节点字体大小，还有一些适配方案，viewport、bootstrap、媒体查询这些都简单说了下。</p>
<h3 id="做过权限没？"><a href="#做过权限没？" class="headerlink" title="做过权限没？"></a>做过权限没？</h3><p>这一块讲了下自己的理解</p>
<p>实际业务开发来讲好像不太难，主要就是给一个标识，来判断到底需不要显示这个路由</p>
<p><strong>你指的标识是什么？</strong></p>
<p>就是来判断是否显示这个路由的字段，可以是一个布尔值，也可以是一个其他的什么字段。通过递归来筛选前端路由有没有这个字段，然后再调用addRoute这个方法，添加到路由中。后端返回的路由信息不能保存到store中，因为刷新store中的数据就清空了</p>
<p>从代码实现上来讲这些都是比较简单的，难的是架构（<strong>其实我也不太懂，瞎吹的</strong>），我们公司项目是用的RBAC权限设计，通过directive封装自定义指令，达到按钮级权限设计。内部主要是appenchild、removeChild 添加移除dom节点来实现</p>
<p>接着我又扯到了需求分解</p>
<h3 id="为什么离职"><a href="#为什么离职" class="headerlink" title="为什么离职"></a>为什么离职</h3><h3 id="你对自己未来发展的规划"><a href="#你对自己未来发展的规划" class="headerlink" title="你对自己未来发展的规划"></a>你对自己未来发展的规划</h3><h3 id="你是怎么规划你的学习路线的"><a href="#你是怎么规划你的学习路线的" class="headerlink" title="你是怎么规划你的学习路线的"></a>你是怎么规划你的学习路线的</h3><h3 id="你对chatgpt怎么看的"><a href="#你对chatgpt怎么看的" class="headerlink" title="你对chatgpt怎么看的"></a>你对chatgpt怎么看的</h3><p>笑了，上午才拿chatgpt帮同事解决了一个正则问题</p>
<p><strong>chatgpt只是工具</strong></p>
<h2 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h2><p>面试官说他比较关注性能优化这一块</p>
<p><strong>上来第一个问题就把我问麻了</strong></p>
<h3 id="你用过正则没，说下正则"><a href="#你用过正则没，说下正则" class="headerlink" title="你用过正则没，说下正则"></a>你用过正则没，说下正则</h3><p>上午才帮同事解决了一个正则问题，没看过正则，都是用了在学，之前看过<strong>高性能javascript</strong>，想到正则还可以做一些优化，，因为实在是记不太清了，就只是提了一嘴。</p>
<h3 id="你在项目中用了是怎么做性能优化"><a href="#你在项目中用了是怎么做性能优化" class="headerlink" title="你在项目中用了是怎么做性能优化"></a>你在项目中用了是怎么做性能优化</h3><p>简单描述了下之前在项目中遇到的下拉框卡顿问题，大数据量几十万条数据引起的卡顿，开启了虚拟列表还是出现卡顿，后面对这个组件在框架的基础上进行了三次封装，集成了分页效果，解决了这个卡顿问题</p>
<p>还有一个是动态高度引起的卡顿问题，简单描述了下实际场景，利用浏览器的开发者工具定位到某个方法，发现是某个方法执行了3s左右，造成的卡顿，由于组件封装复杂，这个方法没法优化只能叫产品改需求，</p>
<p>说了下lighthouse分析报告，因为平常用的不多，简单提了一下</p>
<p>又从构建工具上讲了下优化，vite针对于依赖预构建、分包，静态资源等可以做那些优化，</p>
<p>又讲了下cdn，cdn的缺点，强缓存和协商缓存</p>
<p>又讲了下fcp、fp、首页白屏、骨架屏等</p>
<p>代码层面也可以做优化（够了够了，把我打断了，，你已经说的挺多的了）</p>
<h3 id="csrf攻击怎么防范"><a href="#csrf攻击怎么防范" class="headerlink" title="csrf攻击怎么防范"></a>csrf攻击怎么防范</h3><p>那是去年看的东西，实在是不记得了。</p>
<p>不会的话，不用强答，不要紧，接着就跳过了</p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>知道闭包吗，，我内心已经开始组织语言了，接着来了句没事我不问，哈哈哈哈</p>
<h3 id="怎么做全局捕获"><a href="#怎么做全局捕获" class="headerlink" title="怎么做全局捕获"></a>怎么做全局捕获</h3><p>用window.addEventListener(‘error’,() &#x3D;&gt;{})</p>
<p>提到了自己的个人博客项目，用vue3+node搭了个个人博客项目，接入了阿里云日志和node性能平台，利用docker-compose搭了一个简单的apm，用wsl准备配上sentry的，但是死活安装不了，不知道是不是环境的问题，是不是应该用linux系统。</p>
<p>又说了一下对于性能监控的想法（<strong>只是说一个想法，并不一定是对的</strong>），搭一个后台管理系统，利用window.performance获取到所有性能数据，给这个后台管理系统去做可视化展示</p>
<h3 id="针对你公司的项目，你用到了哪些"><a href="#针对你公司的项目，你用到了哪些" class="headerlink" title="针对你公司的项目，你用到了哪些"></a>针对你公司的项目，你用到了哪些</h3><p>利用vite做的优化，预构建优化，分包等。</p>
<p>提到了想引入一个前端性能监控的sdk，有这个想法但是公司不看重，所以才没有实施</p>
<h3 id="刚刚说到了http，说下你见到得http头有哪些"><a href="#刚刚说到了http，说下你见到得http头有哪些" class="headerlink" title="刚刚说到了http，说下你见到得http头有哪些"></a>刚刚说到了http，说下你见到得http头有哪些</h3><p>一时真没想起来，就简单答了两个，直接跟面试官说，我不记得了，但是你让我看，我大概能知道那些头信息是干什么，面试官就没问了</p>
<p>你的简历上也提到了，会html、css，精通js</p>
<p>我连忙摆手说我不是精通js<br>面试官：哈哈哈哈</p>
<h3 id="说下js异步-1"><a href="#说下js异步-1" class="headerlink" title="说下js异步"></a>说下js异步</h3><h3 id="你欣赏vue的哪些设计"><a href="#你欣赏vue的哪些设计" class="headerlink" title="你欣赏vue的哪些设计"></a>你欣赏vue的哪些设计</h3><p>说了下compiler-core这一块，createApp，render方法</p>
<p>双端diff，这一块的设计，还有响应式</p>
<p>因为源码是去年看的，，没怎么组织好语言，这一块说的有点乱</p>
<h3 id="你擅长什么？"><a href="#你擅长什么？" class="headerlink" title="你擅长什么？"></a>你擅长什么？</h3><p>擅长什么真不好答，我想了一下，，，但是我不擅长的？？比如刚才的web安全、vite、vue3、性能优化等等等</p>
<p>面试官笑了，哈哈哈</p>
<h3 id="未来的发展方向"><a href="#未来的发展方向" class="headerlink" title="未来的发展方向"></a>未来的发展方向</h3><h3 id="你对自己未来发展的规划-1"><a href="#你对自己未来发展的规划-1" class="headerlink" title="你对自己未来发展的规划"></a>你对自己未来发展的规划</h3><p>说了下我现在正在写的项目<a href="https://github.com/lyk990/mini-vite">mini-vite</a></p>
<p>面试官说一面问的都是基础，他比较注重成长性，这也可能是他没有往深问原因吧，，最后说我还不错，在同年人里面算可以的了。</p>
<p>最后又简单聊了下，，问我住哪，我说在龙岗，说高新园上班最好在公司附近租房（这算不算暗示我可能已经面试通过了？？？），，，我说不是我不愿意，我还有女朋友，得跟她商量，</p>
<p>女朋友在哪上班？，，龙岗，，面试官又笑了，，那还是别换地方了吧，虽然一号线人多，，，</p>
<p>问我渴不渴，，等久了给我买了瓶水，，面试官非常nice，面试过程还是非常愉悦的</p>
<h2 id="三面总监面"><a href="#三面总监面" class="headerlink" title="三面总监面"></a>三面总监面</h2><p>自我介绍</p>
<h3 id="怎么改变函数的执行顺序"><a href="#怎么改变函数的执行顺序" class="headerlink" title="怎么改变函数的执行顺序"></a>怎么改变函数的执行顺序</h3><p>一下子没有get到面试官到底要问什么</p>
<p>提到了js的单线程，又说到了宏任务和微任务,.then和.catch</p>
<h3 id="异步能不能理解成多线程"><a href="#异步能不能理解成多线程" class="headerlink" title="异步能不能理解成多线程"></a>异步能不能理解成多线程</h3><p>肯定不能，这是两码事，我在阮一峰的博客上看到的，又说了下js为什么是单线程的</p>
<p>又提到了preload，prefetch</p>
<h3 id="node学了多少"><a href="#node学了多少" class="headerlink" title="node学了多少"></a>node学了多少</h3><p>想用node搭一个前后端的中间层，解决并发大数据量的问题，，但是没找到合适的视频和教程。</p>
<p>只在个人的博客上用过，简单的几个fs、path、process这些模块</p>
<h3 id="你用docker做了什么？"><a href="#你用docker做了什么？" class="headerlink" title="你用docker做了什么？"></a>你用docker做了什么？</h3><p>ci&#x2F;cd，说了下我的个人博客项目，刚开始是用gitlab搭的但是没成功，后面尝试用github action去搭，发现这好像已经不太属于前端的内容了，有点偏离我的学习路线了，而且这一块好像也挺复杂的，也就没有再继续了</p>
<p>搭建前端apm，我还准备讲下部署的，但是因为不太会，所以就没讲了</p>
<h3 id="你对自己未来发展的规划-2"><a href="#你对自己未来发展的规划-2" class="headerlink" title="你对自己未来发展的规划"></a>你对自己未来发展的规划</h3><h3 id="你现在在看哪些书"><a href="#你现在在看哪些书" class="headerlink" title="你现在在看哪些书"></a>你现在在看哪些书</h3><h3 id="最后也跟我说了，要在公司附近租房"><a href="#最后也跟我说了，要在公司附近租房" class="headerlink" title="最后也跟我说了，要在公司附近租房"></a>最后也跟我说了，要在公司附近租房</h3><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>如果是在高新园上班的话，最好要在高新园附近租房</strong></p>
<p>另外，回答的时候最好是扩展开讲，不能面试官问一就答一，不知道或者不太了解的问题试着随便扯下看能不能扯到自己知道的那一块，但是别瞎扯，还有就是引导面试官问问题（？？？但是我提到了好多次vite面试官都没问），可能是因为我一年半的经验，没有深入性的去问，问的都比较浅，好像更多的都是在关注我个人的规划。</p>
<p>面试过程，从开始到结束差不多三个小时，两点半面到五点半，中间还穿插着一些等待时间，总体上来说，三次面试还是非常愉快的，，感觉三个面试官都非常nice，面试的过程也是非常愉悦，三面是总监面的，，总监面完还把我送到门口，</p>
<p><strong>最后结果呢？？ 那肯定是挂了啊</strong></p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>大家如果对vite感兴趣，欢迎关注我的vite项目：<a href="https://juejin.cn/post/7239173192493514808">写了个辅助学习vite的小工具（mini-vite）</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端面试</tag>
      </tags>
  </entry>
  <entry>
    <title>输入一个URL发生了什么</title>
    <url>/posts/42625f19/</url>
    <content><![CDATA[<h3 id="用户输入"><a href="#用户输入" class="headerlink" title="用户输入"></a>用户输入</h3><p>当用户开始在导航栏上面输入内容的时候。UI线程要进行一系列的解析来判定是将用户输入发送给搜索引擎还是直接请求你输入的站点资源。</p>
<ul>
<li>如果是搜索内容，地址栏会使用浏览器默认的搜索引擎，来合成新的带搜索关键字的 URL。</li>
<li>如果判断输入内容符合 URL 规则，比如输入的是 time.geekbang.org，那么地址栏会根据规则，把这段内容加上协议，合成为完整的 URL。</li>
</ul>
<p>当用户按下回车键的时候，UI线程会通知网络进程初始化一个网络请求来获取站点的内容。</p>
<p>这时候tab上的icon会展示一个提示资源正在加载中的旋转圈圈，而且网络进程会进行一系列诸如DNS寻址以及为请求建立TLS连接的操作。</p>
<ul>
<li>tips: 这时如果网络进程收到服务器的HTTP 301重定向响应，它就会告知UI线程进行重定向然后它会再次发起一个新的网络请求。</li>
</ul>
<p>当用户输入关键字并键入回车之后，这意味着当前页面即将要被替换成新的页面，不过在这个流程继续之前，浏览器还给了当前页面一次执行 beforeunload 事件的机会，beforeunload 事件允许页面在退出之前执行一些数据清理操作，还可以询问用户是否要离开当前页面，比如当前页面可能有未提交完成的表单等情况，因此用户可以通过 beforeunload 事件来取消导航，让浏览器不再执行任何后续工作。</p>
<p>当浏览器刚开始加载一个地址之后，标签页上的图标便进入了加载状态（loading）。但此时图中页面显示的依然是之前打开的页面内容，并没立即替换为需要跳转的页面。因为需要等待提交文档阶段，页面内容才会被替换。</p>
<h3 id="URL请求过程"><a href="#URL请求过程" class="headerlink" title="URL请求过程"></a>URL请求过程</h3><p>接下来，便进入了页面资源请求过程。这时，浏览器主进程收到了地址栏的用户输入，</p>
<p><strong>因为浏览器是分为</strong></p>
<ul>
<li><strong>Browser(一个) - 浏览器进程</strong>, 只有一个浏览器进程，负责浏览器的主体部分，包括导航栏，书签， 前进和后退按钮, 提供存储等功能</li>
<li><strong>Network(一个) - 网络进程</strong>, 主要负责页面的<strong>网络资源加载</strong>，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程</li>
<li><strong>GPU(一个) - 图像渲染进程</strong>, 其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。负责独立于其它进程的GPU任务。它之所以被独立为一个进程是因为它要处理来自于不同tab的渲染请求并把它在同一个界面上画出来。</li>
<li><strong>Extensions(多个) - 扩展程序进程</strong></li>
<li><strong>其他进程</strong> - 工具进程，辅助框架等等</li>
</ul>
<p>浏览器发起请求是需要调用网络进程的，因为进程之间的内容是需要相互隔离的，进程隔离是为保护操作系统中进程互不干扰的技术，每一个进程只能访问自己占有的数据，也就避免出现进程 A 写入数据到进程 B 的情况。正是因为进程之间的数据是严格隔离的，当需要跨进程通信的时候，浏览器进程会通过进程间通信机制（IPC）把 URL 请求发送至网络进程。</p>
<p>网络进程接收到 URL 请求后，会在这里发起真正的 URL 请求流程。</p>
<p>首先，网络进程会查找本地缓存是否缓存了该资源。如果有缓存资源，那么直接返回资源给浏览器进程；如果在缓存中没有查找到资源，那么直接进入网络请求流程。这请求前的第一步是要进行 DNS 解析，以获取请求域名的服务器 IP 地址。</p>
<p><strong>DNS解析</strong></p>
<p>因为ip地址是一种用于互联网上访问内容的虚拟地址，要想访问他人的网络就要记住ip地址才行，因为互联网不能通过域名直接访问，系统就会去hosts文件里，去查询这个域名对应的ip地址是什么。然后电脑会去访问这个ip。因为电脑不可能保存所有的域名和对应的ip地址。所以单独出来了一个服务器，让服务器去专门存储这个世界上<strong>绝大多数域名</strong>和ip的映射表，这个服务器就是dns服务器。</p>
<p>如果请求协议是 HTTPS，那么还需要建立 TLS 连接。</p>
<p>接下来就是利用 IP 地址和服务器建立 TCP 连接。连接建立之后，浏览器端会构建请求行、请求头等信息，并把和该域名相关的 Cookie 等数据附加到请求头中，然后向服务器发送构建的请求信息。</p>
<p>服务器接收到请求信息后，会根据请求信息生成响应数据（包括响应行、响应头和响应体等信息），并发给网络进程。等网络进程接收了响应行和响应头之后，就开始解析响应头的内容了。</p>
<p>在接收到服务器返回的响应头后，网络进程开始解析响应头，如果发现返回的状态码是 301 或者 302，那么说明服务器需要浏览器重定向到其他 URL。这时网络进程会从响应头的 Location 字段里面读取重定向的地址，然后再发起新的 HTTP 或者 HTTPS 请求，一切又重头开始了。</p>
<p><strong>在导航过程中，如果服务器响应行的状态码包含了 301、302 一类的跳转信息，浏览器会跳转到新的地址继续导航；如果响应行是 200，那么表示浏览器可以继续处理该请求。</strong></p>
<h4 id="响应数据处理"><a href="#响应数据处理" class="headerlink" title="响应数据处理"></a>响应数据处理</h4><p>在处理了跳转信息之后，浏览器会根据 Content-Type 的值来决定如何显示响应体的内容。</p>
<p>不同 Content-Type 的后续处理流程也截然不同。如果 Content-Type 字段的值被浏览器判断为下载类型，那么该请求会被提交给浏览器的下载管理器，同时该 URL 请求的导航流程就此结束。但如果是 HTML，那么浏览器则会继续进行导航流程。由于 Chrome 的页面渲染是运行在渲染进程中的，所以接下来就需要准备渲染进程了。</p>
<p>网络进程在把内容交给渲染进程之前还会对内容做SafeBrowsing检查，如果请求的域名或者响应的内容和某个已知的病毒网站相匹配，网络进程会给用户展示一个警告的页面。除此之外，网络进程还会做CORB（Cross Origin Read Blocking）检查来确定那些敏感的跨站数据不会被发送至渲染进程。</p>
<h5 id="寻找一个渲染进程来绘制页面"><a href="#寻找一个渲染进程来绘制页面" class="headerlink" title="寻找一个渲染进程来绘制页面"></a>寻找一个渲染进程来绘制页面</h5><p>在网络进程做完所有的检查后并且能够确定浏览器应该导航到该请求的站点，它就会告诉UI线程所有的数据都已经被准备好了。</p>
<p>UI线程在收到网络进程的确认后会为这个网站寻找一个渲染进程（renderer process）来渲染界面</p>
<p>因为网络请求的耗时可能会很长, 所以第二步中当UI线程发送URL链接给网络进程后，它其实已经知晓它们要被导航到哪个站点了。</p>
<p>所以在网络进程干活的时候，UI线程会主动地为这个网络请求启动一个渲染线程。如果一切顺利的话（没有重定向之类的东西出现），网络进程准备好数据后页面的渲染进程已经就准备好了，这就节省了新建渲染进程的时间。</p>
<p>不过如果发生诸如网站被重定向到不同站点的情况，刚刚那个渲染进程就不能被使用了，它会被摒弃，一个新的渲染进程会被启动。</p>
<h5 id="提交导航"><a href="#提交导航" class="headerlink" title="提交导航"></a>提交导航</h5><p>到这一步的时候，数据和渲染进程都已经准备好了，浏览器进程（browser process）会通过IPC告诉渲染进程去提交本次导航（commit navigation）。</p>
<p>除此之外浏览器进程还会将刚刚接收到的响应数据流传递给对应的渲染进程让它继续接收到来的HTML数据。</p>
<p>一旦浏览器进程收到渲染线程的回复说导航已经被提交了（commit），导航这个过程就结束了，文档的加载阶段（document loading phase）会正式开始。</p>
<p>到了这个时候，导航栏会被更新，安全指示符和站点设置会展示新页面相关的站点信息。 当前tab的会话历史（session history）也会被更新，这样当你点击浏览器的前进和后退按钮也可以导航到刚刚导航完的页面。为了方便你在关闭了tab或窗口（window）的时候还可以恢复当前tab和会话（session）内容，当前的会话历史会被保存在磁盘上面。</p>
<h5 id="加载完成"><a href="#加载完成" class="headerlink" title="加载完成"></a>加载完成</h5><p>当导航提交完成后，渲染进程开始着手加载资源以及渲染页面。</p>
<p>一旦渲染进程完成渲染（load），它会通过IPC告知浏览器进程，然后UI线程就会停止导航栏上旋转的圈圈。</p>
<h4 id="准备渲染进程"><a href="#准备渲染进程" class="headerlink" title="准备渲染进程"></a>准备渲染进程</h4><p>到这一步的时候，数据和渲染进程都已经准备好了，浏览器进程（browser process）会通过IPC告诉渲染进程去提交本次导航（commit navigation）。</p>
<p>除此之外浏览器进程还会将刚刚接收到的响应数据流传递给对应的渲染进程让它继续接收到来的HTML数据。</p>
<p>一旦浏览器进程收到渲染线程的回复说导航已经被提交了（commit），导航这个过程就结束了，文档的加载阶段（document loading phase）会正式开始。</p>
<p>到了这个时候，导航栏会被更新，安全指示符和站点设置会展示新页面相关的站点信息。当前tab的会话历史（session history）也会被更新，这样当你点击浏览器的前进和后退按钮也可以导航到刚刚导航完的页面。为了方便你在关闭了tab或窗口（window）的时候还可以恢复当前tab和会话（session）内容，当前的会话历史会被保存在磁盘上面。</p>
<p>默认情况下，Chrome 会为每个页面分配一个渲染进程，也就是说，每打开一个新页面就会配套创建一个新的渲染进程。但是，也有一些例外，在某些情况下，浏览器会让多个页面直接运行在同一个渲染进程中。</p>
<p><strong>那什么情况下多个页面会同时运行在一个渲染进程中呢？</strong></p>
<p>要解决这个问题，我们就需要先了解下什么是同一站点（same-site）。具体地讲，我们将“同一站点”定义为根域名（例如，geekbang.org）加上协议（例如，https:&#x2F;&#x2F; 或者 http:&#x2F;&#x2F;），还包含了该根域名下的所有子域名和不同的端口，比如下面这三个：</p>
<pre><code>https://time.geekbang.org
https://www.geekbang.org
https://www.geekbang.org:8080
</code></pre>
<p>Chrome 的默认策略是，每个标签对应一个渲染进程。但如果从一个页面打开了另一个新页面，而新页面和当前页面属于同一站点的话，那么新页面会复用父页面的渲染进程。官方把这个默认策略叫 process-per-site-instance。</p>
<p>总结来说，打开一个新页面采用的渲染进程策略就是：</p>
<ul>
<li>通常情况下，打开新的页面都会使用单独的渲染进程；</li>
<li>如果从 A 页面打开 B 页面，且 A 和 B 都属于同一站点的话，那么 B 页面复用 A 页面的渲染进程；如果是其他情况，浏览器进程则会为 B 创建一个新的渲染进程。</li>
</ul>
<p>渲染进程准备好之后，还不能立即进入文档解析状态，因为此时的文档数据还在网络进程中，并没有提交给渲染进程，所以下一步就进入了提交文档阶段。</p>
<h4 id="提交文档"><a href="#提交文档" class="headerlink" title="提交文档"></a>提交文档</h4><p>所谓提交文档，就是指浏览器进程将网络进程接收到的 HTML 数据提交给渲染进程，具体流程是这样的：</p>
<ul>
<li>首先当浏览器进程接收到网络进程的响应头数据之后，便向渲染进程发起“提交文档”的消息；</li>
<li>渲染进程接收到“提交文档”的消息后，会和网络进程建立传输数据的“管道”；</li>
<li>等文档数据传输完成之后，渲染进程会返回“确认提交”的消息给浏览器进程；</li>
<li>浏览器进程在收到“确认提交”的消息后，会更新浏览器界面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web 页面。</li>
</ul>
<p>其中，当渲染进程确认提交之后，更新内容如下图所示：</p>
<p><img src="https://lyk990-my-blog.oss-cn-shenzhen.aliyuncs.com/computer-basic/input-url-what-happen/input-url-what-happened.png" alt="image-20221005134118852.png"><br>这也就解释了为什么在浏览器的地址栏里面输入了一个地址后，之前的页面没有立马消失，而是要加载一会儿才会更新页面。</p>
<h4 id="渲染阶段"><a href="#渲染阶段" class="headerlink" title="渲染阶段"></a>渲染阶段</h4><p>一旦页面生成完成，渲染进程会发送一个消息给浏览器进程，浏览器接收到消息后，会停止标签图标上的加载动画。</p>
<p>渲染进程的主要任务是将HTML，CSS，以及JavaScript转变为我们可以进程交互的网页内容。</p>
<p>渲染进程里面有：一个主线程（main thread），几个工作线程（worker threads），一个合成线程（compositor thread）以及一个光栅线程（raster thread）</p>
<p>在渲染进程里面，主线程（main thread）处理了绝大多数你发送给用户的代码。如果你使用了web worker或者service worker，相关的代码将会由工作线程（worker thread）处理。合成（compositor）以及光栅（raster）线程运行在渲染进程里面用来高效流畅地渲染出页面内容。</p>
<h5 id="构建Dom"><a href="#构建Dom" class="headerlink" title="构建Dom"></a>构建Dom</h5><p>渲染进程在导航结束的时候会收到来自浏览器进程提交导航的消息，在这之后渲染进程就会开始接收HTML数据，同时主线程也会开始解析接收到的文本数据，并把它转化为一个DOM（Document Object Model）对象。</p>
<p>上面提到过，渲染进程在导航结束的时候会收到来自浏览器进程提交导航的消息，在这之后渲染进程就会开始接收HTML数据，同时主线程也会开始解析接收到的文本数据，并把它转化为一个DOM（Document Object Model）对象。</p>
<p>DOM对象既是浏览器对当前页面的内部表示，也是Web开发人员通过JavaScript与网页进行交互的数据结构以及API。</p>
<p>如何将HTML文档解析为DOM对象是在HTML标准中定义的。</p>
<p>不过在你的web开发生涯中，你可能从来没有遇到过浏览器在解析HTML的时候发生错误的情景。</p>
<p>这是因为浏览器对HTML的错误容忍度很大。举些例子：如果一个段落缺失了闭合p标签（</p>），这个页面还是会被当做为有效的HTML来处理；</p>
<pre><code>Hi! &lt;b&gt;I&#39;m &lt;i&gt;Chrome&lt;/b&gt;!&lt;/i&gt; 
</code></pre>
<p>虽然有语法错误，不过浏览器会把它处理为</p>
<pre><code>Hi! &lt;b&gt;I&#39;m &lt;i&gt;Chrome&lt;/i&gt;&lt;/b&gt;&lt;i&gt;!&lt;/i&gt;。
</code></pre>
<h5 id="子资源加载"><a href="#子资源加载" class="headerlink" title="子资源加载"></a>子资源加载</h5><p>除了HTML文件，网站通常还会使用到一些诸如图片，CSS样式以及JavaScript脚本等子资源，这些文件会从缓存或者网络上获取。</p>
<p>主线程会按照在构建DOM树时遇到各个资源的循序一个接着一个地发起网络请求，为了提升效率，浏览器会同时运行“预加载扫描”程序。</p>
<p>如果在HTML文档里面存在诸如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;img src=&quot;转存失败，建议直接上传图片文件 &quot; alt=&quot;转存失败，建议直接上传图片文件&quot;&gt;</span><br><span class="line"></span><br><span class="line">或者&lt;link&gt;这样的标签，</span><br></pre></td></tr></table></figure>
<p>预加载扫描程序会在HTML解析器里面找到对应要获取的资源，<strong>并把这些要获取的资源告诉浏览器进程里面的网络线程</strong></p>
<h5 id="JavaScript会阻塞HTML的解析过程"><a href="#JavaScript会阻塞HTML的解析过程" class="headerlink" title="JavaScript会阻塞HTML的解析过程"></a>JavaScript会阻塞HTML的解析过程</h5><p>当HTML解析器碰到script标签的时候，它会停止HTML文档的解析从而转向JavaScript代码的加载，解析以及执行。</p>
<p>为什么要这样做呢？因为script标签中的JavaScript可能会使用诸如document.write()这样的代码改变文档流（document）的形状，从而使整个DOM树的结构发生根本性的改变。因为这个原因，HTML解析器不得不等JavaScript执行完成之后才能继续对HTML文档流的解析工作。</p>
<p>开发者可以通过很多方式告诉浏览器如何才能更加优雅地加载网页需要用到的资源。比如你可以为script标签添加一个async或者defer属性来使JavaScript脚本进行异步加载。<link rel="preload">资源预加载可以用来告诉浏览器这个资源在当前的导航肯定会被用到，你想要尽快加载这个资源。</p>
<h5 id="样式计算-CSS"><a href="#样式计算-CSS" class="headerlink" title="样式计算 CSS"></a>样式计算 CSS</h5><p>主线程会解析页面的CSS从而确定每个DOM节点的计算样式（computed style）。计算样式是主线程根据CSS样式选择器（CSS selectors）计算出的每个DOM元素应该具备的具体样式，即使你的页面没有设置任何自定义的样式，每个DOM节点还是会有一个计算样式属性，这是因为每个浏览器都有自己的默认样式表。 因为这个样式表的存在，页面上的h1标签一定会比h2标签大，而且不同的标签会有不同的magin和padding</p>
<h5 id="布局-Layout"><a href="#布局-Layout" class="headerlink" title="布局 Layout"></a>布局 Layout</h5><p>前面这些步骤完成之后，渲染进程就已经知道页面的具体文档结构以及每个节点拥有的样式信息了，可是这些信息还是不能最终确定页面的样子.</p>
<p>只知道网站的文档流以及每个节点的样式是远远不足以渲染出页面内容的，还需要通过布局（layout）来计算出每个节点的几何信息。</p>
<p>布局的具体过程是：</p>
<ol start="0">
<li>主线程会遍历刚刚构建的DOM树，根据DOM节点的计算样式计算出一个布局树（layout tree）。</li>
<li>布局树上每个节点会有它在页面上的x，y坐标以及盒子大小（bounding box sizes）的具体信息。布局树长得和先前构建的DOM树差不多，不同的是这颗树只有那些可见的（visible）节点信息。</li>
</ol>
<p>举个例子，如果一个节点被设置为了display:none，这个节点就是不可见的就不会出现在布局树上面（visibility:hidden的节点会出现在布局树上面）。同样的，如果一个伪元素（pseudo class）节点有诸如p::before{content:”Hi!”}这样的内容，它会出现在布局上，而不存在于DOM树上。</p>
<h5 id="绘画"><a href="#绘画" class="headerlink" title="绘画"></a>绘画</h5><p>知道了DOM节点以及它的样式和布局其实还是不足以渲染出页面来的。</p>
<p>为什么呢？举个例子，假如你现在想对着一幅画画一幅一样的画，你已经知道了画布上每个元素的大小，形状以及位置，你还是得思考一下每个元素的绘画顺序，因为画布上的元素是会互相遮挡的（z-index）。</p>
<p>如果页面上的某些元素设置了z-index属性，绘制元素的顺序就会影响到页面的正确性。</p>
<h5 id="合成"><a href="#合成" class="headerlink" title="合成"></a>合成</h5><p>浏览器已经知道了关于页面以下的信息：文档结构，元素的样式，元素的几何信息以及它们的绘画顺序。那么浏览器是如何利用这些信息来绘制出页面来的呢？将以上这些信息转化为显示器的像素的过程叫做光栅化（rasterizing）。</p>
<p>现代浏览器采用合成的方式, 来展示整个页面</p>
<p>合成是一种将页面分成若干层，然后分别对它们进行光栅化，最后在一个单独的线程 - 合成线程（compositor thread）里面合并成一个页面的技术。当用户滚动页面时，由于页面各个层都已经被光栅化了，浏览器需要做的只是合成一个新的帧来展示滚动后的效果罢了。页面的动画效果实现也是类似，将页面上的层进行移动并构建出一个新的帧即可。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://time.geekbang.org/column/intro/100033601">浏览器工作原理与实践</a></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>前端面试</tag>
      </tags>
  </entry>
</search>
