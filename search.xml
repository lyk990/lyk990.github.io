<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JavaScript手写代码</title>
    <url>/posts/5b3aed5a/</url>
    <content><![CDATA[<h3 id="1-函数的call-apply-bind"><a href="#1-函数的call-apply-bind" class="headerlink" title="1. 函数的call() &#x2F; apply() &#x2F; bind()"></a>1. 函数的call() &#x2F; apply() &#x2F; bind()</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">自定义函数对象的call方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">call</span> (fn, obj, ...args) &#123;</span><br><span class="line">  <span class="comment">// 如果传入的是null/undefined, this指定为window</span></span><br><span class="line">  <span class="keyword">if</span> (obj===<span class="literal">null</span> || obj===<span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="comment">// obj = window</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">fn</span>(...args)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 给obj添加一个方法: 属性名任意, 属性值必须当前调用call的函数对象</span></span><br><span class="line">  obj.<span class="property">tempFn</span> = fn</span><br><span class="line">  <span class="comment">// 通过obj调用这个方法</span></span><br><span class="line">  <span class="keyword">const</span> result = obj.<span class="title function_">tempFn</span>(...args)</span><br><span class="line">  <span class="comment">// 删除新添加的方法</span></span><br><span class="line">  <span class="keyword">delete</span> obj.<span class="property">tempFn</span></span><br><span class="line">  <span class="comment">// 返回函数调用的结果</span></span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myCall</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> args = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>); <span class="comment">// 获取所有的入参 [&#123; x:10 &#125;, 20, 30]</span></span><br><span class="line">    <span class="keyword">const</span> t = args.<span class="title function_">shift</span>();</span><br><span class="line">    <span class="keyword">if</span> (t === <span class="literal">null</span> || t === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      t = <span class="variable language_">window</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">fn</span>(...args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> self = <span class="variable language_">this</span>; <span class="comment">// 谁调用this就指向谁</span></span><br><span class="line">    t.<span class="property">fn</span> = self;</span><br><span class="line">    <span class="keyword">const</span> res = t.<span class="title function_">fn</span>(...args);</span><br><span class="line">    <span class="keyword">delete</span> t.<span class="property">fn</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a&quot;</span>, a);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;b&quot;</span>, b);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;this&quot;</span>, <span class="variable language_">this</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> res = fn.<span class="title function_">myCall</span>(&#123; <span class="attr">x</span>: <span class="number">10</span> &#125;, <span class="number">20</span>, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">自定义函数对象的apply方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">apply</span> (fn, obj, args) &#123;</span><br><span class="line">  <span class="comment">// 如果传入的是null/undefined, this指定为window</span></span><br><span class="line">  <span class="keyword">if</span> (obj===<span class="literal">null</span> || obj===<span class="literal">undefined</span>) &#123;</span><br><span class="line">    obj = <span class="variable language_">window</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 给obj添加一个方法: 属性名任意, 属性值必须当前调用call的函数对象</span></span><br><span class="line">  obj.<span class="property">tempFn</span> = fn</span><br><span class="line">  <span class="comment">// 通过obj调用这个方法</span></span><br><span class="line">  <span class="keyword">const</span> result = obj.<span class="title function_">tempFn</span>(...args)</span><br><span class="line">  <span class="comment">// 删除新添加的方法</span></span><br><span class="line">  <span class="keyword">delete</span> obj.<span class="property">tempFn</span></span><br><span class="line">  <span class="comment">// 返回函数调用的结果</span></span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">  自定义函数对象的bind方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bind</span> (fn, obj, ...args) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">call</span>(fn, obj, ...args, ...args2)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-函数的节流-throttle-与防抖-debounce"><a href="#2-函数的节流-throttle-与防抖-debounce" class="headerlink" title="2. 函数的节流(throttle)与防抖(debounce)"></a>2. 函数的节流(throttle)与防抖(debounce)</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">用于产生节流函数的工具函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span> (callback, delay) &#123;</span><br><span class="line">  <span class="comment">// 用于保存处理事件的时间, 初始值为0, 保证第一次会执行</span></span><br><span class="line">  <span class="keyword">let</span> start = <span class="number">0</span></span><br><span class="line">  <span class="comment">// 返回事件监听函数 ==&gt; 每次事件发生都会执行</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="comment">// 发生事件的当前时间</span></span><br><span class="line">    <span class="keyword">const</span> current = <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line">    <span class="comment">// 与上一次处理事件的时差大于delay的时间</span></span><br><span class="line">    <span class="keyword">if</span> (current-start&gt;delay) &#123;</span><br><span class="line">      <span class="comment">// 执行处理事件的函数</span></span><br><span class="line">      callback.<span class="title function_">call</span>(event.<span class="property">target</span>, event)</span><br><span class="line">      <span class="comment">// 保证当前时间</span></span><br><span class="line">      start = current</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">用于产生防抖函数的工具函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span> (callback, delay) &#123;</span><br><span class="line">  <span class="comment">// 返回事件监听函数 ==&gt; 每次事件发生都会执行</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果还有未执行的定时器, 清除它</span></span><br><span class="line">    <span class="keyword">if</span> (callback.<span class="property">timeoutId</span>) &#123;</span><br><span class="line">      <span class="built_in">clearTimeout</span>(callback.<span class="property">timeoutId</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 启动延时delay的定时器, 并保证定时器id</span></span><br><span class="line">    callback.<span class="property">timeoutId</span> = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 执行处理事件的函数</span></span><br><span class="line">      callback.<span class="title function_">call</span>(event.<span class="property">target</span>, event)</span><br><span class="line">      <span class="comment">// 删除保存的定时器id</span></span><br><span class="line">      <span class="keyword">delete</span> callback.<span class="property">timeoutId</span></span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-数组去重-unique"><a href="#3-数组去重-unique" class="headerlink" title="3. 数组去重(unique)"></a>3. 数组去重(unique)</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">方法1: 利用forEach()和indexOf()</span></span><br><span class="line"><span class="comment">  双重遍历, 效率差些</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">unique1</span> (array) &#123;</span><br><span class="line">  <span class="keyword">const</span> arr = []</span><br><span class="line">  array.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.<span class="title function_">indexOf</span>(item)===-<span class="number">1</span>) &#123; <span class="comment">// 内部在遍历判断出来的    includes(item)</span></span><br><span class="line">      arr.<span class="title function_">push</span>(item)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">方法2: 利用forEach() + 对象容器</span></span><br><span class="line"><span class="comment">  只需一重遍历, 效率高些</span></span><br><span class="line"><span class="comment">  [1, 3, 5, 3]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">unique2</span> (array) &#123;    </span><br><span class="line">  <span class="keyword">const</span> arr = []</span><br><span class="line">  <span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line">  array.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!obj.<span class="title function_">hasOwnProperty</span>(item)) &#123;<span class="comment">// 不用遍历就能判断出是否已经有了</span></span><br><span class="line">      obj[item] = <span class="literal">true</span></span><br><span class="line">      arr.<span class="title function_">push</span>(item)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">方法3: Array.form + Set</span></span><br><span class="line"><span class="comment">    编码简洁</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">unique3</span> (array) &#123;</span><br><span class="line">  <span class="comment">// return Array.from(new Set(array))</span></span><br><span class="line">  <span class="keyword">return</span> [...<span class="keyword">new</span> <span class="title class_">Set</span>(array)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-数组扁平化-flatten"><a href="#4-数组扁平化-flatten" class="headerlink" title="4. 数组扁平化(flatten)"></a>4. 数组扁平化(flatten)</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">数组扁平化: 取出嵌套数组(多维)中的所有元素放到一个新数组(一维)中</span></span><br><span class="line"><span class="comment">  如: [1, [3, [2, 4]]]  ==&gt;  [1, 3, 2, 4]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">方法一: 递归 + reduce() + concat() + some()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">flatten1</span> (array) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> array.<span class="title function_">reduce</span>(<span class="function">(<span class="params">pre, item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(item) &amp;&amp; item.<span class="title function_">some</span>((<span class="function"><span class="params">cItem</span> =&gt;</span> <span class="title class_">Array</span>.<span class="title function_">isArray</span>(cItem)))) &#123;</span><br><span class="line">      <span class="keyword">return</span> pre.<span class="title function_">concat</span>(<span class="title function_">flatten1</span>(item))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> pre.<span class="title function_">concat</span>(item)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">方法二: ... + some() + concat()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">flatten2</span> (arr) &#123;</span><br><span class="line">  <span class="comment">// 只要arr是一个多维数组(有元素是数组)</span></span><br><span class="line">  <span class="keyword">while</span> (arr.<span class="title function_">some</span>(<span class="function"><span class="params">item</span> =&gt;</span> <span class="title class_">Array</span>.<span class="title function_">isArray</span>(item))) &#123;</span><br><span class="line">    <span class="comment">// 对arr进行降维</span></span><br><span class="line">    arr = [].<span class="title function_">concat</span>(...arr)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">方法三: ... + some() + concat()</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="keyword">var</span> arr = [</span><br><span class="line">        [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>],</span><br><span class="line">        [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>],</span><br><span class="line">        [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>],</span><br><span class="line">        [<span class="number">11</span>, <span class="number">12</span>, [<span class="number">12</span>, <span class="number">12</span>, [<span class="number">13</span>]]],</span><br><span class="line">        <span class="number">10</span>,</span><br><span class="line">      ];</span><br><span class="line">      <span class="comment">// 数组扁平化</span></span><br><span class="line">      <span class="comment">// 去重</span></span><br><span class="line">      <span class="comment">// 排序</span></span><br><span class="line">      <span class="comment">// 不能使用箭头函数（this会指向window）</span></span><br><span class="line">      <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">flat</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> result = <span class="variable language_">this</span>.<span class="title function_">map</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(item)) &#123;</span><br><span class="line">            <span class="keyword">return</span> item.<span class="title function_">flat</span>();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> [item];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> [].<span class="title function_">concat</span>(...result);</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="comment">// 去重</span></span><br><span class="line">      <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">unique</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> [...<span class="keyword">new</span> <span class="title class_">Set</span>(<span class="variable language_">this</span>)];</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="comment">// 排序</span></span><br><span class="line">      <span class="keyword">const</span> <span class="title function_">sortFn</span> = (<span class="params">a, b</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> a - b;</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="keyword">const</span> a = arr.<span class="title function_">flat</span>().<span class="title function_">unique</span>().<span class="title function_">sort</span>(sortFn);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="5-深拷贝"><a href="#5-深拷贝" class="headerlink" title="5. 深拷贝"></a>5. 深拷贝</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">深度克隆</span></span><br><span class="line"><span class="comment">1). 大众乞丐版</span></span><br><span class="line"><span class="comment">    问题1: 函数属性会丢失</span></span><br><span class="line"><span class="comment">    问题2: 循环引用会出错</span></span><br><span class="line"><span class="comment">2). 面试基础版本</span></span><br><span class="line"><span class="comment">    解决问题1: 函数属性还没丢失</span></span><br><span class="line"><span class="comment">3). 面试加强版本</span></span><br><span class="line"><span class="comment">    解决问题2: 循环引用正常</span></span><br><span class="line"><span class="comment">4). 面试加强版本2(优化遍历性能)</span></span><br><span class="line"><span class="comment">    数组: while | for | forEach() 优于 for-in | keys()&amp;forEach() </span></span><br><span class="line"><span class="comment">    对象: for-in 与 keys()&amp;forEach() 差不多</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    cloneDeep()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: &#123;</span><br><span class="line">       <span class="attr">m</span>: <span class="number">1</span> </span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">b</span>: [<span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">    <span class="attr">fn</span>: <span class="keyword">function</span> (<span class="params"></span>)&#123;&#125;,</span><br><span class="line">    <span class="attr">d</span>: <span class="string">&#x27;abc&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">obj.<span class="property">a</span>.<span class="property">c</span> = obj.<span class="property">b</span></span><br><span class="line">obj.<span class="property">b</span>[<span class="number">2</span>] = obj.<span class="property">a</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">1). 大众乞丐版</span></span><br><span class="line"><span class="comment">  问题1: 函数属性会丢失</span></span><br><span class="line"><span class="comment">  问题2: 循环引用会出错</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">deepClone1</span>(<span class="params">target</span>) &#123; <span class="comment">// 从后台获取的数据都可以用</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(target))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">获取数据的类型字符串名</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getType</span>(<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(data).<span class="title function_">slice</span>(<span class="number">8</span>, -<span class="number">1</span>)  <span class="comment">// -1代表最后一位</span></span><br><span class="line">    <span class="comment">// [object Array]  ===&gt; Array  [object Object] ==&gt; Object</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2). 面试基础版本</span></span><br><span class="line"><span class="comment">  解决问题1: 函数属性还没丢失</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">deepClone2</span>(<span class="params">target</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> type = <span class="title function_">getType</span>(target)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (type===<span class="string">&#x27;Object&#x27;</span> || type===<span class="string">&#x27;Array&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> cloneTarget = type === <span class="string">&#x27;Array&#x27;</span> ? [] : &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> target) &#123;</span><br><span class="line">      <span class="keyword">if</span> (target.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">        cloneTarget[key] = <span class="title function_">deepClone2</span>(target[key])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cloneTarget</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">3). 面试加强版本</span></span><br><span class="line"><span class="comment">  解决问题2: 循环引用正常</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">deepClone3</span>(<span class="params">target, map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> type = <span class="title function_">getType</span>(target)</span><br><span class="line">  <span class="keyword">if</span> (type===<span class="string">&#x27;Object&#x27;</span> || type===<span class="string">&#x27;Array&#x27;</span>) &#123;</span><br><span class="line">     <span class="comment">// 从map容器取对应的clone对象</span></span><br><span class="line">    <span class="keyword">let</span> cloneTarget = map.<span class="title function_">get</span>(target)</span><br><span class="line">    <span class="comment">// 如果有, 直接返回这个clone对象</span></span><br><span class="line">    <span class="keyword">if</span> (cloneTarget) &#123;</span><br><span class="line">      <span class="keyword">return</span> cloneTarget</span><br><span class="line">    &#125;</span><br><span class="line">    cloneTarget = type===<span class="string">&#x27;Array&#x27;</span> ? [] : &#123;&#125;</span><br><span class="line">    <span class="comment">// 将clone产生的对象保存到map容器</span></span><br><span class="line">    map.<span class="title function_">set</span>(target, cloneTarget)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> target) &#123;</span><br><span class="line">      <span class="keyword">if</span> (target.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">        cloneTarget[key] = <span class="title function_">deepClone3</span>(target[key], map)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cloneTarget</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">4). 面试加强版本2(优化遍历性能)</span></span><br><span class="line"><span class="comment">    数组: while | for | forEach() 优于 for-in | keys()&amp;forEach() </span></span><br><span class="line"><span class="comment">    对象: for-in 与 keys()&amp;forEach() 差不多</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">deepClone4</span>(<span class="params">target, map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> type = <span class="title function_">getType</span>(target)</span><br><span class="line">  <span class="keyword">if</span> (type===<span class="string">&#x27;Object&#x27;</span> || type===<span class="string">&#x27;Array&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 判断是否拷贝完成</span></span><br><span class="line">    <span class="keyword">let</span> cloneTarget = map.<span class="title function_">get</span>(target)</span><br><span class="line">    <span class="keyword">if</span> (cloneTarget) &#123;</span><br><span class="line">      <span class="keyword">return</span> cloneTarget</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (type===<span class="string">&#x27;Array&#x27;</span>) &#123;</span><br><span class="line">      cloneTarget = []</span><br><span class="line">      map.<span class="title function_">set</span>(target, cloneTarget)</span><br><span class="line">      target.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">        cloneTarget[index] = <span class="title function_">deepClone4</span>(item, map)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      cloneTarget = &#123;&#125;</span><br><span class="line">      map.<span class="title function_">set</span>(target, cloneTarget)</span><br><span class="line">      <span class="title class_">Object</span>.<span class="title function_">keys</span>(target).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">        cloneTarget[key] = <span class="title function_">deepClone4</span>(target[key], map)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cloneTarget</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-自定义new和instanceof工具函数"><a href="#6-自定义new和instanceof工具函数" class="headerlink" title="6. 自定义new和instanceof工具函数"></a>6. 自定义new和instanceof工具函数</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">自定义new工具函数</span></span><br><span class="line"><span class="comment">  语法: newInstance(Fn, ...args)</span></span><br><span class="line"><span class="comment">  功能: 创建Fn构造函数的实例对象</span></span><br><span class="line"><span class="comment">  实现: 创建空对象obj, 调用Fn指定this为obj, 返回obj</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">newInstance</span>(<span class="params">Fn, ...args</span>) &#123;</span><br><span class="line">  <span class="comment">// 创建一个新的对象</span></span><br><span class="line">  <span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line">  <span class="comment">// 执行构造函数</span></span><br><span class="line">  <span class="keyword">const</span> result = <span class="title class_">Fn</span>.<span class="title function_">apply</span>(obj, args) <span class="comment">// 相当于: obj.Fn()</span></span><br><span class="line">  <span class="comment">// 如果构造函数执行的结果是对象, 返回这个对象</span></span><br><span class="line">  <span class="keyword">if</span> (result <span class="keyword">instanceof</span> <span class="title class_">Object</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 给obj指定__proto__为Fn的prototype</span></span><br><span class="line">  obj.<span class="property">__proto__</span> = <span class="title class_">Fn</span>.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line">  <span class="comment">// 如果不是, 返回新创建的对象</span></span><br><span class="line">  <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Fn</span> () &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;tom&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> []</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Fn</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">自定义instanceof工具函数: </span></span><br><span class="line"><span class="comment">  语法: myInstanceOf(obj, Type)</span></span><br><span class="line"><span class="comment">  功能: 判断obj是否是Type类型的实例</span></span><br><span class="line"><span class="comment">  实现: Type的原型对象是否是obj的原型链上的某个对象, 如果是返回true, 否则返回false</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myInstanceOf</span>(<span class="params">obj, Type</span>) &#123;</span><br><span class="line">  <span class="comment">// 得到原型对象</span></span><br><span class="line">  <span class="keyword">let</span> protoObj = obj.<span class="property">__proto__</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 只要原型对象存在</span></span><br><span class="line">  <span class="keyword">while</span>(protoObj) &#123;</span><br><span class="line">    <span class="comment">// 如果原型对象是Type的原型对象, 返回true</span></span><br><span class="line">    <span class="keyword">if</span> (protoObj === <span class="title class_">Type</span>.<span class="property"><span class="keyword">prototype</span></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 指定原型对象的原型对象</span></span><br><span class="line">    protoObj = protoObj.<span class="property">__proto__</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-字符串处理"><a href="#7-字符串处理" class="headerlink" title="7. 字符串处理"></a>7. 字符串处理</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">1. 字符串倒序: reverseString(str)  生成一个倒序的字符串</span></span><br><span class="line"><span class="comment">2. 字符串是否是回文: palindrome(str) 如果给定的字符串是回文，则返回 true ；否则返回 false</span></span><br><span class="line"><span class="comment">3. 截取字符串: truncate(str, num) 如果字符串的长度超过了num, 截取前面num长度部分, 并以...结束</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">1. 字符串倒序: reverseString(str)  生成一个倒序的字符串</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reverseString</span>(<span class="params">str</span>) &#123;  <span class="comment">// abc</span></span><br><span class="line">  <span class="comment">// return str.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;)</span></span><br><span class="line">  <span class="comment">// return [...str].reverse().join(&#x27;&#x27;)</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(str).<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">2. 字符串是否是回文: palindrome(str) 如果给定的字符串是回文，则返回 true ；否则返回 false</span></span><br><span class="line"><span class="comment">    abcba  abccba</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">palindrome</span>(<span class="params">str</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> str === <span class="title function_">reverseString</span>(str)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">3. 截取字符串: truncate(str, num) 如果字符串的长度超过了num, 截取前面num长度部分, 并以...结束</span></span><br><span class="line"><span class="comment">abcde...</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">truncate</span>(<span class="params">str, num</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> str.<span class="property">length</span> &gt; num ? str.<span class="title function_">slice</span>(<span class="number">0</span>, num) + <span class="string">&#x27;...&#x27;</span> : str</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">abcdd...</span><br></pre></td></tr></table></figure>
<h3 id="8-简单排序-冒泡-选择-插入"><a href="#8-简单排序-冒泡-选择-插入" class="headerlink" title="8. 简单排序: 冒泡 &#x2F; 选择 &#x2F; 插入"></a>8. 简单排序: 冒泡 &#x2F; 选择 &#x2F; 插入</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">冒泡排序的方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bubbleSort</span> (array) &#123;</span><br><span class="line">  <span class="comment">// 1.获取数组的长度</span></span><br><span class="line">  <span class="keyword">var</span> length = array.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.反向循环, 因此次数越来越少</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="comment">// 3.根据i的次数, 比较循环到i位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">      <span class="comment">// 4.如果j位置比j+1位置的数据大, 那么就交换</span></span><br><span class="line">      <span class="keyword">if</span> (array[j] &gt; array[j + <span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="comment">// 交换</span></span><br><span class="line">        <span class="comment">// const temp = array[j+1]</span></span><br><span class="line">        <span class="comment">// array[j+1] = array[j]</span></span><br><span class="line">        <span class="comment">// array[j] = temp</span></span><br><span class="line">        [array[j + <span class="number">1</span>], array[j]] = [array[j], array[j + <span class="number">1</span>]];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">选择排序的方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">selectSort</span> (array) &#123;</span><br><span class="line">  <span class="comment">// 1.获取数组的长度</span></span><br><span class="line">  <span class="keyword">var</span> length = array.<span class="property">length</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.外层循环: 从0位置开始取出数据, 直到length-2位置</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 3.内层循环: 从i+1位置开始, 和后面的内容比较</span></span><br><span class="line">    <span class="keyword">var</span> min = i</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = min + <span class="number">1</span>; j &lt; length; j++) &#123;</span><br><span class="line">      <span class="comment">// 4.如果i位置的数据大于j位置的数据, 记录最小的位置</span></span><br><span class="line">      <span class="keyword">if</span> (array[min] &gt; array[j]) &#123;</span><br><span class="line">        min = j</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (min !== i) &#123;</span><br><span class="line">      <span class="comment">// 交换</span></span><br><span class="line">      [array[min], array[i]] = [array[i], array[min]];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">插入排序的方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">insertSort</span> (array) &#123;</span><br><span class="line">  <span class="comment">// 1.获取数组的长度</span></span><br><span class="line">  <span class="keyword">var</span> length = array.<span class="property">length</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.外层循环: 外层循环是从1位置开始, 依次遍历到最后</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="comment">// 3.记录选出的元素, 放在变量temp中</span></span><br><span class="line">    <span class="keyword">var</span> j = i</span><br><span class="line">    <span class="keyword">var</span> temp = array[i]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.内层循环: 内层循环不确定循环的次数, 最好使用while循环</span></span><br><span class="line">    <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; array[j - <span class="number">1</span>] &gt; temp) &#123;</span><br><span class="line">      array[j] = array[j - <span class="number">1</span>]</span><br><span class="line">      j--</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.将选出的j位置, 放入temp元素</span></span><br><span class="line">    array[j] = temp</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> array</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">products.<span class="title function_">sort</span>(<span class="function">(<span class="params">item1, item2</span>) =&gt;</span> &#123;  </span><br><span class="line">    <span class="comment">// 返回正数, item2在右边, 返回负数, item1在右边, 返回0为原本顺序</span></span><br><span class="line">    <span class="keyword">return</span> item1.<span class="property">price</span> - item2.<span class="property">price</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="9、继承"><a href="#9、继承" class="headerlink" title="9、继承"></a>9、继承</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//封装一个父类</span></span><br><span class="line">       <span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age, sex</span>) &#123;</span><br><span class="line">           <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">           <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">           <span class="variable language_">this</span>.<span class="property">sex</span> = sex;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">eat</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">           <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;螺蛳粉&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="comment">//封装一个子类</span></span><br><span class="line">       <span class="keyword">function</span> <span class="title function_">Student</span>(<span class="params">classRoom, score, name, age, sex</span>) &#123;</span><br><span class="line">           <span class="variable language_">this</span>.<span class="property">classRoom</span> = classRoom;</span><br><span class="line">           <span class="variable language_">this</span>.<span class="property">score</span> = score;</span><br><span class="line">           <span class="comment">//构造函数继承调用父类，并把父类的this指向自己的this</span></span><br><span class="line">           <span class="title class_">Person</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name, age, sex)</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//以下方法缺点：1.eat共享了  2.如果继承多个属性或方法 需要一个个添加</span></span><br><span class="line">       <span class="comment">// Student.prototype.eat = Person.prototype.eat;</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//以下方法的缺点：1.赋值是地址的赋值，子类和父类的原型对象共享了  2.构造器属性也是不对的</span></span><br><span class="line">       <span class="comment">// Student.prototype = Person.prototype;</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//原型对象继承:把父类的实例化对象 当做自己的原型对象</span></span><br><span class="line">       <span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Person</span>;</span><br><span class="line">       <span class="comment">//修正构造器属性(添加constructor属性)</span></span><br><span class="line">       <span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Student</span>;</span><br><span class="line">       <span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">study</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">           <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;面向对象&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="keyword">var</span> s1 = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">405</span>, <span class="number">100</span>, <span class="string">&quot;张三&quot;</span>, <span class="number">18</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(s1);</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(s1.<span class="property">eat</span>);</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(s1.<span class="property">study</span>);</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(s1.<span class="property">constructor</span>);</span><br></pre></td></tr></table></figure>
<h3 id="10、js调度器（并发编程）"><a href="#10、js调度器（并发编程）" class="headerlink" title="10、js调度器（并发编程）"></a>10、js调度器（并发编程）</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Scheduler</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">max</span>) &#123;</span><br><span class="line">    <span class="comment">// 最大可并发任务数</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">max</span> = max;</span><br><span class="line">    <span class="comment">// 当前并发任务数</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">count</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 阻塞的任务队列</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">queue</span> = [];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">add</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">count</span> &gt;= <span class="variable language_">this</span>.<span class="property">max</span>) &#123;</span><br><span class="line">      <span class="comment">// 若当前正在执行的任务，达到最大容量max</span></span><br><span class="line">      <span class="comment">// 阻塞在此处，等待前面的任务执行完毕后将resolve弹出并执行</span></span><br><span class="line">      <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="title function_">push</span>(resolve));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前并发任务数++</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">count</span>++;</span><br><span class="line">    <span class="comment">// 使用await执行此函数</span></span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">fn</span>();</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">0</span></span><br><span class="line">    a++</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res, a)</span><br><span class="line">    <span class="comment">// 执行完毕，当前并发任务数--</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">count</span>--;</span><br><span class="line">    <span class="comment">// 若队列中有值，将其resolve弹出，并执行</span></span><br><span class="line">    <span class="comment">// 以便阻塞的任务，可以正常执行</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="property">length</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="title function_">shift</span>()();</span><br><span class="line">    <span class="comment">// 返回函数执行的结果</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">sleep</span> = (<span class="params">time</span>) =&gt;</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, time);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> scheduler = <span class="keyword">new</span> <span class="title class_">Scheduler</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">addTask</span> = (<span class="params">time, val</span>) =&gt; &#123;</span><br><span class="line">  scheduler.<span class="title function_">add</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">sleep</span>(time).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(val);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">addTask</span>(<span class="number">1000</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">  <span class="title function_">addTask</span>(<span class="number">200</span>, <span class="string">&quot;5&quot;</span>);</span><br><span class="line">  <span class="title function_">addTask</span>(<span class="number">500</span>, <span class="string">&quot;2&quot;</span>);</span><br><span class="line">  <span class="title function_">addTask</span>(<span class="number">300</span>, <span class="string">&quot;3&quot;</span>);</span><br><span class="line">  <span class="title function_">addTask</span>(<span class="number">400</span>, <span class="string">&quot;4&quot;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="11、手写async和await"><a href="#11、手写async和await" class="headerlink" title="11、手写async和await"></a>11、手写async和await</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// generator函数</span></span><br><span class="line"><span class="comment">// async、await的特征是能暂停执行并能恢复执行</span></span><br><span class="line"><span class="comment">// generator的特征也是如此  </span></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span> <span class="comment">// yield用来暂停执行</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span> <span class="comment">// next（）方法来恢复执行</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> g = <span class="title function_">gen</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>())	<span class="comment">// &#123;value: 1, done: false&#125; value是返回的值，done是generator函数是否已经走完</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>())	<span class="comment">// &#123;value: 2, done: false&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>())	<span class="comment">// &#123;value: 3, done: false&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>())	<span class="comment">// &#123;value: 4, done: false&#125;  // 最终的返回值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">sixuetang</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> data1 = <span class="keyword">await</span> <span class="title function_">getData</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">const</span> data2 = <span class="keyword">await</span> <span class="title function_">getData</span>(data1);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`success: <span class="subst">$&#123;data2&#125;</span>`</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">function</span>* <span class="title function_">sixuetang</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> data1 = <span class="keyword">yield</span> <span class="title function_">getData</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">const</span> data2 = <span class="keyword">yield</span> <span class="title function_">getData</span>(data1);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`success: <span class="subst">$&#123;data2&#125;</span>`</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> g = <span class="title function_">sixuetang</span>();</span><br><span class="line">      <span class="keyword">const</span> next1 = g.<span class="title function_">next</span>(); <span class="comment">// &#123;value: Promise&#123;&lt;fulfilled&gt;&#125;, done: false&#125;</span></span><br><span class="line"></span><br><span class="line">      next1.<span class="property">value</span>.<span class="title function_">then</span>(<span class="function">(<span class="params">data1</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;data1: &quot;</span>, data1);</span><br><span class="line">        <span class="keyword">const</span> next2 = g.<span class="title function_">next</span>(data1);</span><br><span class="line">        next2.<span class="property">value</span>.<span class="title function_">then</span>(<span class="function">(<span class="params">data2</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;data2: &quot;</span>, data2);</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>(data2));</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">	<span class="comment">// 封装一个适用性更强</span></span><br><span class="line">      <span class="keyword">function</span> <span class="title function_">generatorToAsync</span>(<span class="params">generatorFun</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> g = <span class="title function_">generatorFun</span>();</span><br><span class="line">            <span class="keyword">const</span> next1 = g.<span class="title function_">next</span>();</span><br><span class="line">            next1.<span class="property">value</span>.<span class="title function_">then</span>(<span class="function">(<span class="params">data1</span>) =&gt;</span> &#123;</span><br><span class="line">              <span class="keyword">const</span> next2 = g.<span class="title function_">next</span>(data1);</span><br><span class="line">              next2.<span class="property">value</span>.<span class="title function_">then</span>(<span class="function">(<span class="params">data2</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="title function_">resolve</span>(g.<span class="title function_">next</span>(data2).<span class="property">value</span>);</span><br><span class="line">              &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">function</span> <span class="title function_">generatorToAsync</span>(<span class="params">generatorFun</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">          <span class="keyword">const</span> gen = generatorFun.<span class="title function_">apply</span>(<span class="variable language_">this</span>.<span class="property">arguments</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">function</span> <span class="title function_">step</span>(<span class="params">key, arg</span>) &#123;</span><br><span class="line">              <span class="keyword">let</span> res;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                res = gen[key](arg);</span><br><span class="line">              &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="title function_">reject</span>(error);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">const</span> &#123; value, done &#125; = res;</span><br><span class="line">              <span class="keyword">if</span> (done) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="title function_">resolve</span>(value);</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(value).<span class="title function_">then</span>(</span><br><span class="line">                  <span class="function">(<span class="params">val</span>) =&gt;</span> <span class="title function_">step</span>(<span class="string">&quot;next&quot;</span>, val),</span><br><span class="line">                  <span class="function">(<span class="params">err</span>) =&gt;</span> <span class="title function_">step</span>(<span class="string">&quot;throw&quot;</span>, err)</span><br><span class="line">                );</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="title function_">step</span>(<span class="string">&quot;next&quot;</span>);</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> asyncFn = <span class="title function_">generatorToAsync</span>(sixuetang);</span><br><span class="line">      <span class="title function_">asyncFn</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(res));</span><br></pre></td></tr></table></figure>
<h3 id="12、函数柯里化"><a href="#12、函数柯里化" class="headerlink" title="12、函数柯里化"></a>12、函数柯里化</h3><h4 id="精简版柯里化"><a href="#精简版柯里化" class="headerlink" title="精简版柯里化"></a>精简版柯里化</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">curring</span> = (<span class="params">protocol</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">hostname, pathname</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;protocol&#125;</span><span class="subst">$&#123;hostname&#125;</span><span class="subst">$&#123;pathname&#125;</span>`</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> https = <span class="title function_">curring</span>(<span class="string">&quot;https://&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> uri = <span class="title function_">https</span>(<span class="string">&#x27;www.baidu.com&#x27;</span>, <span class="string">&#x27;/picture&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(uri) <span class="comment">// https://www.baidu.com/picture</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、如何通过数组解耦获取属性值</span></span><br><span class="line"><span class="keyword">const</span> list = [</span><br><span class="line">  &#123;<span class="attr">mid</span>:<span class="string">&#x27;123&#x27;</span>, <span class="attr">per</span>:<span class="string">&#x27;123&#x27;</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">mid</span>: <span class="string">&#x27;qqq&#x27;</span>, <span class="attr">per</span>: <span class="string">&#x27;2222&#x27;</span>&#125;</span><br><span class="line">]</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">curring</span> = key =&gt; <span class="function"><span class="params">item</span> =&gt;</span> item[key]</span><br><span class="line"><span class="keyword">const</span> mid = <span class="title function_">curring</span>(<span class="string">&#x27;mid&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> per = <span class="title function_">curring</span>(<span class="string">&#x27;per&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(list.<span class="title function_">map</span>(mid))    <span class="comment">// [ &#x27;123&#x27;, &#x27;qqq&#x27; ]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(list.<span class="title function_">map</span>(per))    <span class="comment">// [ &#x27;123&#x27;, &#x27;2222&#x27; ]</span></span><br></pre></td></tr></table></figure>

<h4 id="柯里化-隐式调用"><a href="#柯里化-隐式调用" class="headerlink" title="柯里化 (隐式调用)"></a>柯里化 (隐式调用)</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">num</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(...args) <span class="comment">// 1 2 3·</span></span><br><span class="line">  <span class="keyword">return</span> args</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">num</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此方法无法无限输入参数链式调用</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a</span>) &#123;</span><br><span class="line">  <span class="comment">// arguments是一个类数组对象，</span></span><br><span class="line">  <span class="comment">// 可通过Array.prototype.slice.call 转换成数组</span></span><br><span class="line">  <span class="comment">// Array.prototype.slice.call(arguments)能将具有length属性的对象转成数组</span></span><br><span class="line">  <span class="keyword">let</span> args = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">  <span class="keyword">let</span> inner = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    args.<span class="title function_">push</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line">    <span class="keyword">let</span> sum = args.<span class="title function_">reduce</span>(<span class="keyword">function</span> (<span class="params">perv, cur</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> prev + cur</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> inner</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add</span>(<span class="number">1</span>)(<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过修改toString 隐式调用来达到柯里化的目的，但是输出的是一个函数类型</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a</span>) &#123;</span><br><span class="line">  <span class="comment">// arguments是一个类数组对象，</span></span><br><span class="line">  <span class="comment">// 可通过Array.prototype.slice.call 转换成数组</span></span><br><span class="line">  <span class="comment">// Array.prototype.slice.call(arguments)能将具有length属性的对象转成数组</span></span><br><span class="line">  <span class="keyword">let</span> args = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">  <span class="keyword">let</span> inner = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    args.<span class="title function_">push</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line">  &#125;</span><br><span class="line">  inner.<span class="property">toString</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> args.<span class="title function_">reduce</span>(<span class="keyword">function</span> (<span class="params">prev, cur</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> prev + cur</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> inner</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">curring</span> = (<span class="params">func</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> args = [];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">result</span>(<span class="params">...rest</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(rest.<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">func</span>(...args)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            args.<span class="title function_">push</span>(...rest);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<h4 id="定制柯里化"><a href="#定制柯里化" class="headerlink" title="定制柯里化"></a>定制柯里化</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 求和函数</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">sumFn</span> = (<span class="params">...args</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> args.<span class="title function_">reduce</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 对参数进行排序</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">sortFn</span> = (<span class="params">...args</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> args.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    a - b;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">curring</span> = (<span class="params">func</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> args = [];</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">result</span>(<span class="params">...rest</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (rest.<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">func</span>(...args);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      args.<span class="title function_">push</span>(...rest);</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">curring</span>(sumFn)(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)(<span class="number">6</span>)() )  <span class="comment">// 21</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">curring</span>(sortFn)(<span class="number">1</span>)(<span class="number">3</span>)(<span class="number">2</span>)(<span class="number">5</span>, <span class="number">4</span>)() )    <span class="comment">//  [1,2,3,4,5]</span></span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.bilibili.com/video/BV1XZ4y1y7BX/?spm_id_from=333.337.search-card.all.click&vd_source=ad69edc9a457e7180dde2d7baf02ad26">JS每日一题：如何设计一个任务队列？控制请求最大并发数</a></li>
<li><a href="https://www.bilibili.com/video/BV1yS4y1C786/?spm_id_from=333.337.search-card.all.click&vd_source=ad69edc9a457e7180dde2d7baf02ad26">JS每日一题：一道编程题来了解函数柯里化的妙用</a></li>
<li><a href="https://www.bilibili.com/video/BV13a41187yp/?spm_id_from=333.337.search-card.all.click&vd_source=ad69edc9a457e7180dde2d7baf02ad26">手写async</a></li>
<li><a href="https://juejin.cn/post/6844904052237713422">初、中级前端应该要掌握的手写代码实现</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端面试</tag>
      </tags>
  </entry>
  <entry>
    <title>AOP装饰函数在前端中的应用</title>
    <url>/posts/803cab72/</url>
    <content><![CDATA[<blockquote>
<p>在传统的面向对象编程中，给对象添加功能常常采用继承的方式，但是继承的方式并不灵活。在实现一些功能时，有可能会创建出大量子类</p>
</blockquote>
<h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><p>在JavaScript中可以很方便的给某个对象添加属性或者方法，但是很难在不改动源代码的基础上给函数添加新的功能。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假如当前我们的代码是这样的</span></span><br><span class="line"> <span class="keyword">const</span> <span class="title function_">a</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line"> &#125;;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 我想添加一个打印2的功能, 这个时候可以直接修改源代码</span></span><br><span class="line"> <span class="keyword">const</span> <span class="title function_">a</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line"> &#125;;     </span><br></pre></td></tr></table></figure>
<p>但是在实际开发中，我们往往接手的是上一个同事留下的代码，鬼知道他在这一段代码里面做了什么。。。。。这个时候可能就要求我们在不改变源代码的基础上给函数增加新的功能。那么我们就可以用到<strong>装饰器</strong>了</p>
<h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><p>在 JavaScript 中，自身并没有原生支持装饰器模式。装饰器模式是一种结构性设计模式，它允许你通过将对象包装在一个或多个装饰器中，以动态地添加或修改对象的行为。<strong>装饰器（Decorator）模式，是一种在运行期动态给某个对象的实例增加功能的方法。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用高阶函数实现装饰器模式</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">withLogging</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Calling function with arguments: <span class="subst">$&#123;args&#125;</span>`</span>);</span><br><span class="line">      <span class="keyword">const</span> result = <span class="title function_">fn</span>(...args);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Function result: <span class="subst">$&#123;result&#125;</span>`</span>);</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> decoratedAdd = <span class="title function_">withLogging</span>(add);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">decoratedAdd</span>(<span class="number">2</span>, <span class="number">3</span>));  <span class="comment">// Output: 5</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用类继承实现装饰器模式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Coffee</span> &#123;</span><br><span class="line">    <span class="title function_">cost</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">MilkDecorator</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Coffee</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">coffee</span>) &#123;</span><br><span class="line">      <span class="variable language_">super</span>();</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_coffee</span> = coffee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">cost</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_coffee</span>.<span class="title function_">cost</span>() + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">SugarDecorator</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Coffee</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">coffee</span>) &#123;</span><br><span class="line">      <span class="variable language_">super</span>();</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_coffee</span> = coffee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">cost</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_coffee</span>.<span class="title function_">cost</span>() + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> coffee = <span class="keyword">new</span> <span class="title class_">Coffee</span>();</span><br><span class="line">  coffee = <span class="keyword">new</span> <span class="title class_">MilkDecorator</span>(coffee);</span><br><span class="line">  coffee = <span class="keyword">new</span> <span class="title class_">SugarDecorator</span>(coffee);</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(coffee.<span class="title function_">cost</span>()); <span class="comment">// Output: 8</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用类成员实现装饰器模式</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">logProperty</span>(<span class="params">target, key, descriptor</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> originalValue = descriptor.<span class="property">value</span>;</span><br><span class="line"></span><br><span class="line">    descriptor.<span class="property">value</span> = <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Calling method <span class="subst">$&#123;key&#125;</span> with arguments: <span class="subst">$&#123;args&#125;</span>`</span>);</span><br><span class="line">      <span class="keyword">const</span> result = originalValue.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Method result: <span class="subst">$&#123;result&#125;</span>`</span>);</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> descriptor;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">MathOperations</span> &#123;</span><br><span class="line">    @logProperty</span><br><span class="line">    <span class="title function_">add</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @logProperty</span><br><span class="line">    <span class="title function_">subtract</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> a - b;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> math = <span class="keyword">new</span> <span class="title class_">MathOperations</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(math.<span class="title function_">add</span>(<span class="number">5</span>, <span class="number">3</span>));</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(math.<span class="title function_">subtract</span>(<span class="number">10</span>, <span class="number">4</span>));</span><br></pre></td></tr></table></figure>



<h2 id="AOP装饰函数的应用"><a href="#AOP装饰函数的应用" class="headerlink" title="AOP装饰函数的应用"></a>AOP装饰函数的应用</h2><p>回到最初的问题，如何在不影响源代码的基础上，给函数添加新的功能</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 利用AOP装饰函数来解决这个问题</span></span><br><span class="line"> <span class="keyword">const</span> <span class="title function_">a</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">addLogProperty</span>(<span class="params">targetFunction</span>) &#123;</span><br><span class="line">    targetFunction.<span class="property">additionalLog</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> targetFunction;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> decoratedA = <span class="title function_">addLogProperty</span>(a);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">decoratedA</span>(); <span class="comment">// Output: 1</span></span><br><span class="line">  decoratedA.<span class="title function_">additionalLog</span>(); <span class="comment">// Output: 2</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>在编写一个函数时，可利用AOP装饰器增加函数的扩展性，可以动态的去为这个函数添加功能，不用去修改源代码。</p>
<p>用AOP装饰函数的技巧在实际开发中非常有用。不管是业务的编写，还是系统框架的设计，都可以把行为按照职责分成粒度更加细粒的函数，随后通过装饰把他们合并到一起。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>JavaScript设计模式与开发实践 <strong>[书籍]</strong></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端架构管理</tag>
      </tags>
  </entry>
  <entry>
    <title>AOP在前端编程中的应用</title>
    <url>/posts/4e6f4a5d/</url>
    <content><![CDATA[<p>最近在学代码优化的时候，看到了AOP(面向切面编程)，听着好像挺厉害的，就把他记录了下来</p>
<h2 id="什么是AOP"><a href="#什么是AOP" class="headerlink" title="什么是AOP"></a>什么是AOP</h2><p>面向对象的特点是继承、多态和封装。而封装就要求将功能分散到不同的对象中去，这在软件设计中往往称为职责分配。实际上也就是说，让不同的类设计不同的方法。这样代码就分散到一个个的类中去了。这样做的好处是降低了代码的复杂程度，使类可重用。  </p>
<p>但是人们也发现，在分散代码的同时，也增加了代码的重复性。什么意思呢？比如说，我们在两个类中，可能都需要在每个方法中做日志。按面向对象的设计方法，我们就必须在两个类的方法中都加入日志的内容。也许他们是完全相同的，但就是因为面向对象的设计让类与类之间无法联系，而不能将这些重复的代码统一起来。  </p>
<p>也许有人会说，那好办啊，我们可以将这段代码写在一个独立的类独立的方法里，然后再在这两个类中调用。但是，这样一来，这两个类跟我们上面提到的独立的类就有耦合了，它的改变会影响这两个类。那么，有没有什么办法，能让我们在需要的时候，随意地加入代码呢？<strong>这种在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是AOP(面向切面的编程)。</strong>  </p>
<p>一般而言，我们管切入到指定类指定方法的代码片段称为切面，而切入到哪些类、哪些方法则叫切入点。有了AOP，我们就可以把几个类共有的代码，抽取到一个切片中，等到需要时再切入对象中去，从而改变其原有的行为。</p>
<p>这样看来，AOP其实只是OOP的补充而已。OOP从横向上区分出一个个的类来，而AOP则从纵向上向对象中加入特定的代码。有了AOP，OOP变得立体了。如果加上时间维度，AOP使OOP由原来的二维变为三维了，由平面变成立体了。从技术上来说，AOP基本上是通过代理机制实现的。</p>
<p><a href="https://www.iteye.com/blog/hejiajunsh-1776569">上面的这一段话附上链接</a></p>
<h2 id="为什么会叫做切面"><a href="#为什么会叫做切面" class="headerlink" title="为什么会叫做切面"></a>为什么会叫做切面</h2><p>AOP的主要思想是将应用程序中存在耦合的功能模块进行封装，这些模块通常与核心业务逻辑无关，但是在应用程序的多个地方都需要进行处理。<br>例如：一个网站，存在以下几个功能</p>
<ul>
<li>登录</li>
<li>注册</li>
<li>日志记录</li>
</ul>
<p>登录、注册就是核心业务逻辑，而日志记录则不属于核心逻辑，但是多个地方都需要复用。在AOP中，就可以将日志记录的逻辑定义为一个切面，然后通过配置或代码来指定在哪个地方来应用这个切面。</p>
<p>在面向对象编程中，很多业务逻辑都在混杂在一起，导致代码的可读性和可维护性下降。AOP就是将这些非核心业务逻辑抽离出来，形成独立的模块，然后通过一种<strong>切面</strong>的机制，AOP框架会在编译时或者运行时，将其动态的织入应用程序的核心逻辑中。</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 出自JavaScript设计模式与开发实践3.2.3（高阶函数实现AOP）</span></span><br><span class="line">  <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">before</span> = <span class="keyword">function</span> (<span class="params">beforeFn</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> _self = <span class="variable language_">this</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">          beforeFn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">          <span class="keyword">return</span> _self.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">after</span> = <span class="keyword">function</span> (<span class="params">afterFn</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> _self = <span class="variable language_">this</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">          <span class="keyword">const</span> ret = _self.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">          afterFn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">          <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> func = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      func = func</span><br><span class="line">        .<span class="title function_">before</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">        .<span class="title function_">after</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="title function_">func</span>();</span><br><span class="line">      </span><br><span class="line">    输出:</span><br><span class="line">      <span class="number">1</span></span><br><span class="line">      <span class="number">2</span></span><br><span class="line">      <span class="number">3</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>看着好像非常疑惑，这样写的意义何在，这些代码主要是为了帮助理解AOP。其实简单来讲就是，通过函数调用，找到对应的切入点（PointCut），再从切入点中对应的织入（Weaving）动作，这样来实现逻辑解耦。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li>书籍： JavaScript设计模式与开发实践</li>
<li><a href="https://zhuanlan.zhihu.com/p/269504590">简谈前端开发中的AOP(一) – 前端AOP的实现思路</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/468837058">简谈前端开发中的AOP(二) – 前端AOP的发展与完善</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端架构管理</tag>
      </tags>
  </entry>
  <entry>
    <title>写了个辅助学习vite的小工具</title>
    <url>/posts/5862c0a6/</url>
    <content><![CDATA[<h2 id="仓库地址-mini-vite"><a href="#仓库地址-mini-vite" class="headerlink" title="仓库地址 mini-vite"></a>仓库地址 <a href="https://github.com/lyk990/mini-vite">mini-vite</a></h2><h2 id="文章链接"><a href="#文章链接" class="headerlink" title="文章链接"></a><a href="https://juejin.cn/post/7239173192493514808">文章链接</a></h2>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端项目管理</tag>
      </tags>
  </entry>
  <entry>
    <title>坐标深圳，面试了一个三年经验的前端</title>
    <url>/posts/9de14610/</url>
    <content><![CDATA[<blockquote>
<p>说一下背景，公司为创业型公司，项目组才创建，目前只有我一个前端，我个人的招聘需求是不要求技术非常厉害，只要喜欢钻研学、喜欢思考、平时能多沟通，最重要的是<strong>写代码的时候能吹牛逼</strong>就行。如果能比我强，带带我，那肯定更好。</p>
</blockquote>
<ul>
<li>想看面经的我还有一篇文章<a href="https://juejin.cn/post/7239484016947724347#comment">深圳前端一年半，投了两个月简历，第一场面试</a></li>
</ul>
<p>这次的简历是我老大筛出来的，原本是他去面的，但是他开会去了，所以我就临时去面了，此次面试者是一位<strong>三年工作经验的前端，主要技术栈是vue3、vite</strong></p>
<h2 id="平常有没有自己造轮子或者看一些开源的项目"><a href="#平常有没有自己造轮子或者看一些开源的项目" class="headerlink" title="平常有没有自己造轮子或者看一些开源的项目"></a>平常有没有自己造轮子或者看一些开源的项目</h2><p>面试者：有看github，看vue相关的开源</p>
<p>我的想法：面试者的简历没有写关于这些的内容，我问这个问题的原因，主要想看面试者是否有关注一些开源项目，会不会去造轮子，我平常也会看github或者一些文章之类的，希望能从这个问题延伸开，开始面试。</p>
<p>接着问，能说一下具体的是哪方面的开源吗，组件库还是一个工具库还是一个框架，或者文章、博客都行，简单介绍下</p>
<p>面试者：不记得了。。。</p>
<p>我的想法：有些开发者没有逛开源的习惯，这个不一定能考察到面试者是否喜欢钻研思考，直接开始下一个问题吧</p>
<h2 id="从0到1搭建一个项目你会考虑哪些问题"><a href="#从0到1搭建一个项目你会考虑哪些问题" class="headerlink" title="从0到1搭建一个项目你会考虑哪些问题"></a>从0到1搭建一个项目你会考虑哪些问题</h2><p>面试者：从设计稿出发，查看哪些组件需要抽离封装成全局组件的，或者哪些组件要进行封装等。。。</p>
<p>我的想法：项目组刚刚创建，同时开展了三个项目，涉及到<strong>后台管理系统、app和小程序</strong>，三个项目都是我从零开始搭建的，项目组只有我一个人，目前三个项目的基础架构、技术选型、技术方案、以及前端基础建设都是我一个人在做，后续如果有新项目要开的话，希望有人能和我探讨一下这方面的问题</p>
<p>问这个问题的目的，主要是想考察一下面试者有没有尝试过自己搭建一个项目，或者有没有思考过这类问题。面试者只是从设计稿组件的角度简单说明了一下，我可能更多的希望面试者能从技术选型、或者项目基础建设，或者能根据业务来输出自己的一部分观点，例如一些工程化配置（eslit、git husky等）、或者ci&#x2F;cd、性能监控、还有code review、开发规范或者技术分享等、</p>
<p>我觉得他可能没有回答到我想要的点子上，于是我就接着问</p>
<h2 id="技术选型，你会考虑哪些问题"><a href="#技术选型，你会考虑哪些问题" class="headerlink" title="技术选型，你会考虑哪些问题"></a>技术选型，你会考虑哪些问题</h2><p>面试者：。。。。东扯西扯</p>
<p>说的乱七八糟的。。。。。我直接打断，</p>
<p>我的想法：问这个问题的目的是想看面试者有没有站在项目管理者的角度思考过问题，例如我们为什么要用这个组件库，这个组件库优势在哪，为什么不用其他的组件库，最好是能列出场景来举例说明</p>
<p>我给他讲述我的思路：其实可以从社区生态，issue、pr，性能、优势和劣势，以及未来可能会出现的问题等方面来回答，你们之前的项目是用的uview， uview和uni-ui，uni-ui的优势就是兼容性好、性能好等，dclound团队开发的，但是问题就是功能不够强大，可能不太能满足开发需求，uview的优势就是兼容app和小程序，组件库功能多，用的人多生态比较好，但是问题就是可能会不太稳定，现在作者维护的比较少，提的issue中的bug也比较多，如果出现bug，后续可以采取打补丁或者直接改源码的方式来修复</p>
<p>接着问vue</p>
<h2 id="vue文件是怎么被解析渲染呈现到浏览器上面的"><a href="#vue文件是怎么被解析渲染呈现到浏览器上面的" class="headerlink" title="vue文件是怎么被解析渲染呈现到浏览器上面的"></a>vue文件是怎么被解析渲染呈现到浏览器上面的</h2><p>面试者：没有怎么研究过源码的实现</p>
<p>我的想法：这个问题主要想问的是vue的源码实现，可以从vue3源码中的render，mount来回答，但是除了源码实现之外，还可以延伸讲到babel、Esmodule，vite&#x2F;webpack构建工具、浏览器渲染等，再延伸还可以讲到操作系统、组成原理等</p>
<p>这个问题深度和广度都有涉及，好像是难了一点，既然面试者没有看过底层源码实现，那就算了，vue也不问了，无非就是调两个api而已，能写业务就行，再问些八股文的面试题没什么意义，知道怎么用vue的api就行</p>
<p>我问：你对vite熟悉点还是webpack熟悉点？</p>
<p>对vite熟悉点</p>
<h2 id="有了解过依赖预构建吗"><a href="#有了解过依赖预构建吗" class="headerlink" title="有了解过依赖预构建吗"></a>有了解过依赖预构建吗</h2><p>面试者：叽里呱啦。。。。</p>
<p>面试者说的比较乱，我听不大明白，但是好像还是回答到了点子上，vite按需预构建依赖，可能只是没有组织好语言而已，所以有点卡壳，</p>
<p>本来还想问下vite热更新的实现的，算了算了，能知道vite或者webpack这些玩意怎么配置就行。太过于深究没多大意义，大部分人都不太会去研究这玩意</p>
<p>如果想看下vite底层实现的话，可以看下我的这篇文章：<a href="https://juejin.cn/post/7239173192493514808">写了个辅助学习vite的小工具（mini-vite）</a></p>
<p>或者我的github  <a href="https://github.com/lyk990/mini-vite">https://github.com/lyk990/mini-vite</a></p>
<h2 id="你用vite做了哪些配置"><a href="#你用vite做了哪些配置" class="headerlink" title="你用vite做了哪些配置"></a>你用vite做了哪些配置</h2><p>面试者：图片的优化，console的优化配置等</p>
<p>能知道有这些插件、配置就行了，</p>
<p>看了一眼他的简历，发现面试者简历上的项目大部分是uniapp的移动端项目，去年就开始了，基本上都是用的vue3+vite，于是接着提问</p>
<h2 id="你在去年就直接用vue3来写uniapp了，有没有遇到什么bug，遇到之后是怎么修复的呢"><a href="#你在去年就直接用vue3来写uniapp了，有没有遇到什么bug，遇到之后是怎么修复的呢" class="headerlink" title="你在去年就直接用vue3来写uniapp了，有没有遇到什么bug，遇到之后是怎么修复的呢"></a>你在去年就直接用vue3来写uniapp了，有没有遇到什么bug，遇到之后是怎么修复的呢</h2><p>面试者：vue3的组件库可能不够多，需要自己封装组件，遇到bug就自己封装组件</p>
<p>我接着问：去年上半年就使用vue3，风险有点大啊，你们为什么会选择vue3呢</p>
<p>面试者：这个技术栈主要是产品经理选的，是他确定下来的，</p>
<p>我的想法：吹牛逼吧，产品经理？？？？？产品经理还管这事？？？</p>
<p>接着提问</p>
<h2 id="介绍一下你最熟悉的一个项目"><a href="#介绍一下你最熟悉的一个项目" class="headerlink" title="介绍一下你最熟悉的一个项目"></a>介绍一下你最熟悉的一个项目</h2><p>面试者：一个抽奖的小程序，主要有。。，叽里呱啦说完</p>
<p>听到了关键词支付，想从支付开始提问，逐步延伸到他的项目和业务上面去</p>
<p>我问：看到你提到了支付，能说一下微信支付有哪些api吗</p>
<p>面试者：不记得了</p>
<p>。。。。。。。自己写得代码，用的哪个api还能不记得？？？？？</p>
<p>接着问</p>
<h2 id="你的vite图片优化，是用的哪个插件呢，叫什么？"><a href="#你的vite图片优化，是用的哪个插件呢，叫什么？" class="headerlink" title="你的vite图片优化，是用的哪个插件呢，叫什么？"></a>你的vite图片优化，是用的哪个插件呢，叫什么？</h2><p>面试者：不记得了</p>
<p>我的想法：这是你刚才自己说的图片优化，用的哪个插件都不知道。。。。。</p>
<p>再问下去好像没多大意义了，直接结束吧。。。</p>
<h2 id="你的意向薪资是多少"><a href="#你的意向薪资是多少" class="headerlink" title="你的意向薪资是多少"></a>你的意向薪资是多少</h2><p>面试者：9到10</p>
<p>三年经验，9到10。。。。。。。</p>
<p>面试结束</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次的面试按照三年经验的简历来问的问题，主要从项目管理者的角度来进行的提问，主要涉及到项目管理、源码实现。</p>
<p>因为我自己从来不背八股文，所以没有问一些八股文面试题。对于我来说，<strong>前端技术这么多，学是学不完的，无非就是看下文档调两个api而已</strong>，底层才是不变的，我可能更看重<strong>谷歌搜索</strong>能力还有<strong>debug能力</strong>以及<strong>求知</strong>的意识</p>
<p>我在提问时希望能从和面试者的聊天中逐步的延伸，然后发起提问，面试者回答的时候最好是能<strong>结合场景来进行回答</strong></p>
<p>最后说一句，最开始不知道面试者的意向薪资，所以直接按照三年经验问的问题，我要是知道他的薪资要的这么低，我肯定不会这么问。。。。下次先问意向薪资，再提问！</p>
<ul>
<li>想看面经的我还有一篇文章<a href="https://juejin.cn/post/7239484016947724347#comment">深圳前端一年半，投了两个月简历，第一场面试</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端面试</tag>
      </tags>
  </entry>
  <entry>
    <title>怎么写出好看的代码？</title>
    <url>/posts/2cb0a095/</url>
    <content><![CDATA[<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eef371b317c943fa8f0b42c8d67fca2b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=635&h=710&s=514895&e=png&b=0a0914" alt="image.png"></p>
<blockquote>
<p>是的,我觉得代码就应该写得跟诗一样优雅,代码不是给自己看的,是给别人看的.虽然我的日常是搬砖,但是我也希望能把砖码得整整齐齐的.</p>
</blockquote>
<h2 id="打造自己的代码风格"><a href="#打造自己的代码风格" class="headerlink" title="打造自己的代码风格"></a>打造自己的代码风格</h2><p>什么叫自己的代码风格?</p>
<p>在我刚刚开始学习前端的时候,我写出的代码可能是这样的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不注意等号前后缩进,单双引号随意使用</span></span><br><span class="line"><span class="keyword">const</span> dog= &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;black&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="string">&quot;9&quot;</span>,</span><br><span class="line">  <span class="attr">gender</span>: <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 随意的函数命名</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fn</span>= (<span class="params"></span>)=&gt;&#123;</span><br><span class="line">  <span class="comment">// if else 语句的大括号前后不加空格</span></span><br><span class="line">  <span class="keyword">if</span> (dog.<span class="property">age</span> &gt; <span class="number">8</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;old&quot;</span>);&#125; <span class="comment">//这里的大括号也不会换行</span></span><br><span class="line">  dog.<span class="property">name</span>=<span class="string">&quot;white&quot;</span>; <span class="comment">// 等号前后不加空格</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">say</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 使用很多的if else语句</span></span><br><span class="line">    <span class="keyword">if</span> (dog.<span class="property">name</span> === <span class="string">&quot;white&quot;</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;white&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dog.<span class="property">name</span> === <span class="string">&quot;black&quot;</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;black&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;other&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 整个代码看上去会比较杂乱</span></span><br></pre></td></tr></table></figure>
<p>通过长时间的搬砖,现在我的代码是这样的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意等号前后缩进，属性值全部使用双引号</span></span><br><span class="line">  <span class="keyword">const</span> dog = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;black&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="string">&quot;9&quot;</span>,</span><br><span class="line">    <span class="attr">gender</span>: <span class="number">0</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 使用小驼峰和英文翻译命名变量名称</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handlerDog</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 注意if else 的空格及换行</span></span><br><span class="line">    <span class="keyword">if</span> (dog.<span class="property">age</span> &gt; <span class="number">8</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;old&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    dog.<span class="property">name</span> = <span class="string">&quot;white&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">say</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// 对if else进行提取优化</span></span><br><span class="line">      <span class="keyword">const</span> mapList = &#123;</span><br><span class="line">        <span class="attr">white</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;white&quot;</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">black</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;black&quot;</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">other</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;other&quot;</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="comment">// 会考虑代码的扩展性及健壮性，以及常见的边界判断</span></span><br><span class="line">      mapList[dog.<span class="property">name</span>]() ?? mapList[<span class="string">&quot;other&quot;</span>](); </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<h3 id="掌握编程规范"><a href="#掌握编程规范" class="headerlink" title="掌握编程规范"></a>掌握编程规范</h3><ul>
<li><p>单双引号的使用、等号前后缩进、大括号前后缩进都需要注意,哪怕是没有代码格式化工具,也能有自己的一套代码规范</p>
</li>
<li><p>项目、目录、文件等全部采用小写方式， 以中划线(“-“)分隔，有复数时加”s”， 缩写不用复数。</p>
<p>正例: src&#x2F;shop-order-details&#x2F;index.vue</p>
<p>反例: src&#x2F;shopOrderDetails&#x2F;index.vue</p>
</li>
<li><p>如果变量命名的好,我可能连注释都不需要,比如这样:</p>
</li>
</ul>
<p> <img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/019fe40436d447c3b845159c3407d4ad~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=575&h=34&s=4231&e=png&b=515b6a" alt="image.png"></p>
<ul>
<li><p>添加注释能增进同事间友谊</p>
<ul>
<li>注释应该是能解释这段代码的作用,能让同事看得懂</li>
<li>但是也不用每一行都注释,这就有点冗余了</li>
</ul>
</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3bd31a26dfb641ff96f2043174a4465e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=762&h=316&s=31024&e=png&b=1e1e1e" alt="image.png"></p>
<ul>
<li>不要一大串函数直接撸下来,找个合适的地方换行</li>
</ul>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/062536ddccf44994b6f513cf3f67872a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=601&h=334&s=27347&e=png&b=1e1e1e" alt="image.png"></p>
<p>再往上走就要考虑代码的设计了</p>
<h2 id="代码设计"><a href="#代码设计" class="headerlink" title="代码设计"></a>代码设计</h2><p>好的代码应该有这么几种特性:可读性、扩展性、健壮性等</p>
<p>对代码进行优化时需要降低代码的耦合度和复杂度,对耦合的代码封装,达到复用的目的,在封装的时候需要考虑一些异常场景,提高代码的健壮性,同时最好不要将函数的功能直接写死.大部分场景只有成功或失败两种状态,但是搞不好还有个不成功也不失败,所以函数的扩展性也是需要保证的,简单来讲就是不能写死.</p>
<p>例如现在给你的需求是这个订单的状态只有成功或失败,所以你直接使用了一个三元表达式来进行处理,但是后面可能产品跟你说你搞错了,这个订单有成功失败还有退款中三种状态,那就完了,你懵逼了,要对代码进行重构了,我就这样干过.</p>
<p>遵循一些代码设计思路、掌握一些代码优化技巧,可以帮助我们更好的改进自己的代码</p>
<h3 id="健壮性"><a href="#健壮性" class="headerlink" title="健壮性"></a>健壮性</h3><p>为代码添加一系列的边界判断,异常处理等<br>合理使用JavaScript运算符</p>
<ul>
<li><p><code>?.</code> 是一个条件式属性访问操作符，当你访问值为<code>undefined</code>变量的某个属性值时，如果使用<code>.</code>操作符会直接报错，如果使用条件式属性访问操作符来访问会返回<code>undefined</code></p>
<ul>
<li>例如: e?.stopPropagation()</li>
</ul>
</li>
<li><p><code>??</code>逻辑空赋值运算符（<code>x ?? y</code>）仅在 <code>x</code> 是<code>空值</code>（<code>null</code> 或 <code>undefined</code>）时对其赋值。</p>
<ul>
<li>例如: opt?.searchInfo ?? {}</li>
</ul>
</li>
<li><p><code>||</code> 逻辑或( <code>x || y</code> ) 仅在 <code>x</code> 是<code>空值</code>（<code>null</code> 或 <code>undefined</code>）时,返回右边的值(<code>y</code>)</p>
<ul>
<li>例如: v-bind&#x3D;”data || {}”</li>
</ul>
</li>
<li><p>使用<code>try catch</code> 对异常进行捕获处理</p>
</li>
</ul>
<h3 id="扩展性"><a href="#扩展性" class="headerlink" title="扩展性"></a>扩展性</h3><p>使用策略模式对代码进行优化</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 之前的代码</span></span><br><span class="line"> <span class="keyword">if</span> (dog.<span class="property">name</span> === <span class="string">&quot;white&quot;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;white&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dog.<span class="property">name</span> === <span class="string">&quot;black&quot;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;black&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;other&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 现在的代码</span></span><br><span class="line"> <span class="keyword">const</span> mapList = &#123;</span><br><span class="line">    <span class="attr">white</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;white&quot;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">black</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;black&quot;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">other</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;other&quot;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 会考虑代码的扩展性及健壮性，以及常见的边界判断</span></span><br><span class="line">  mapList[dog.<span class="property">name</span>]() ?? mapList[<span class="string">&quot;other&quot;</span>](); </span><br></pre></td></tr></table></figure>

<h3 id="可读性"><a href="#可读性" class="headerlink" title="可读性"></a>可读性</h3><p>对函数进行封装,同时尽量减少代码量,降低代码的耦合度,添加注释,并尽量取一个好理解的函数名</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8fe6ba3a3fe44829830458c983514c83~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=542&h=500&s=41732&e=png&b=1e1e1e" alt="image.png"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>JavaScript设计模式与开发实践</li>
<li>代码整洁之道</li>
<li>重构2</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>文章分类模板</title>
    <url>/posts/401e296e/</url>
    <content><![CDATA[<h2 id="初始化项目分类及标签"><a href="#初始化项目分类及标签" class="headerlink" title="初始化项目分类及标签"></a>初始化项目分类及标签</h2><p>tags: </p>
<ul>
<li>前端面试</li>
<li>前端架构管理</li>
<li>前端监控</li>
<li>前端性能优化</li>
<li>前端源码解析</li>
<li>前端项目管理</li>
</ul>
<p>categories: </p>
<ul>
<li>前端</li>
<li>后端</li>
<li>计算机基础</li>
</ul>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>前端面试</tag>
        <tag>前端架构管理</tag>
        <tag>前端项目管理</tag>
        <tag>前端性能优化</tag>
        <tag>前端源码解析</tag>
        <tag>前端监控</tag>
      </tags>
  </entry>
  <entry>
    <title>深圳前端一年半，投了两个月简历，第一场面试</title>
    <url>/posts/2a476d98/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><blockquote>
<p>base深圳，一年半经验，找的初级前端岗位，1-3年，投简历两个月只有两个面试，这是第一个面试</p>
</blockquote>
<h2 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h2><h3 id="你对html元素是怎么分类的？"><a href="#你对html元素是怎么分类的？" class="headerlink" title="你对html元素是怎么分类的？"></a>你对html元素是怎么分类的？</h3><p>一开始我愣了一下？搞这么简单的问题？？？后面又问面试官你是指的id选择器这些吗，，还是display：block,inline-block这些？不管了，反正我全都讲了一遍，说了下这些八股文基础，感觉有点简单，说得有点少。另外又展开说了HTML DOM节点那些内容</p>
<p><strong>image是行内元素为什么有宽高？</strong></p>
<p>这个问题我倒是没有了解过啊，想了下说，会不会和input或者什么video之类的差不多，对于这类元素，浏览器有其他的解析方式（万能答法：问什么都能答<strong>浏览器解析</strong>）</p>
<p>面试官让我了解下可替换元素，，img属于<strong>可替换元素</strong></p>
<h3 id="你用过哪些http状态码？"><a href="#你用过哪些http状态码？" class="headerlink" title="你用过哪些http状态码？"></a>你用过哪些http状态码？</h3><p>因为没有刻意的去背这些玩意，所以只是大概做了下分类。就回答了常见的状态码，比如101我就在websocket上见过，200或者201就是请求成功，3开头大概就是重定向的，又展开说了下永久重定向和临时重定向的区别，4开头的大概就是前端问题，比如401就是没有权限没有token，404请求url错误，5开头的大概就是后端问题，只说了自己见过的一些状态码</p>
<p><strong>404就一定是前端问题吗？</strong></p>
<p>不一定，状态码是可以修改的，比如接口抛错我也可以搞个404，前后端联调可以协商的</p>
<h3 id="说下强缓存和协商缓存"><a href="#说下强缓存和协商缓存" class="headerlink" title="说下强缓存和协商缓存"></a>说下强缓存和协商缓存</h3><p>搞忘记是请求头的哪个字段了，几个月都没看过http方面的内容了，好像是cache-control,只记得一个no-store，这个是不缓存，简单讲了下强缓存和协商缓存的区别，强缓存就是直接从缓存中拿取数据，不用再发请求，会有一个过期时间来判断是否命中，协商缓存通过Last-Modified（文件上次修改时间）和etag（文件内容是否变化）来命中。</p>
<p>接着又展开讲了下磁盘缓存（disk cache）和内存缓存（memory cache）的区别，从读取速度，缓存资源大小展开讲了下</p>
<p>突然想到了vite，最近在学习vite，就又讲了下vite的<strong>分包</strong>处理，vite用到的<strong>强缓存</strong>和<strong>协商缓存</strong></p>
<h3 id="说下js异步"><a href="#说下js异步" class="headerlink" title="说下js异步"></a>说下js异步</h3><p>除了常见的八股文回答知识</p>
<p>我又提到了async和await，<strong>async和await的内部实现</strong>，是怎么通过generator，yield，next()来实现的</p>
<p>还讲了下<strong>不同的执行环境，js的执行机制也会有区别</strong>，在node环境和浏览器环境js异步执行的区别。</p>
<h3 id="说下es6的新特性"><a href="#说下es6的新特性" class="headerlink" title="说下es6的新特性"></a>说下es6的新特性</h3><p>let const、map、set，,weakmap,weakset,解构，简单提了下，在vue3源码中用到的weakmap，准备说下内存泄漏的，，但是这玩意太难了，想了想还是没说了，就说了这几个、跟面试官说还有一些语法，但是不知道怎么描述，别的突然一下子想不起来了</p>
<h3 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h3><p>我还以为要我手写，我直接回答，这玩意手写我不会，我都是直接引入lodash的，什么手写call、apply、bind这些，我都不会，结果面试官不要我手写，，是我太敏感了（主要是对这种手写代码太厌恶了）</p>
<p>按照八股文面试题简单讲了下区别，主要就是<strong>堆栈中地址值的传递</strong></p>
<p>接着又展开讲到了<strong>内存、cpu、进程、堆和栈</strong>。堆和栈是放在进程中的，而进程又会被装入内存中，栈和堆本质上都只是内存中的一片区域，编写的一行行代码都会被转成指令，保存到内存中，cpu就是从内存中获取指令并执行。这些太久没学了记不太清，不敢说得太多，就简单说了下</p>
<h3 id="打包之后哪些文件会被解析成ventor文件"><a href="#打包之后哪些文件会被解析成ventor文件" class="headerlink" title="打包之后哪些文件会被解析成ventor文件"></a>打包之后哪些文件会被解析成ventor文件</h3><p>其实我也不太了解，说了个node_modules也不知道对不对，然后就简单讲了下vite分包，，怎么做分包</p>
<h3 id="vite预构建依赖是怎么做的"><a href="#vite预构建依赖是怎么做的" class="headerlink" title="vite预构建依赖是怎么做的"></a>vite预构建依赖是怎么做的</h3><p>当时正在写<a href="https://github.com/lyk990/mini-vite">mini-vite</a>，面试官看我老是提vite，可能就随便问了下，主要就是计算出入口文件，通过esbuild进行依赖扫描，然后将其打包放在指定得文件夹内，会根据打包的内容生成一个hash值，内容改变hash值也会改变，保存在一个json文件中，每次开启项目时都会对比这个hash值来判断是否需要重新预构建依赖</p>
<h3 id="vue的数组为什么不能做响应式"><a href="#vue的数组为什么不能做响应式" class="headerlink" title="vue的数组为什么不能做响应式"></a>vue的数组为什么不能做响应式</h3><p>没看vue2的源码，好像是读取不到数组的长度（可能回答的是错误的），直接跟面试官说不太了解vue2的源码，平常都是看的vue3源码，但是还是强行扯了两句，用vue2响应式跟vue3做了对比，扯到了<strong>vue3响应式</strong>，<strong>收集依赖和触发依赖</strong>。然后提到了，proxy、reflect，又说了一下这个es6的新特性，在vue3中的源码是怎么用的。</p>
<h3 id="你有移动端项目，，肯定做了适配吧，，怎么做的适配？"><a href="#你有移动端项目，，肯定做了适配吧，，怎么做的适配？" class="headerlink" title="你有移动端项目，，肯定做了适配吧，，怎么做的适配？"></a>你有移动端项目，，肯定做了适配吧，，怎么做的适配？</h3><p>我笑了，不好意思，还真没做适配，移动端项目主要是给我们公司内部使用，所以移动端都是固定的屏幕大小，用不到适配。</p>
<p>不过我大学毕业设计的项目用过，用的淘宝适配方案，主要就是改变根节点字体大小，还有一些适配方案，viewport、bootstrap、媒体查询这些都简单说了下。</p>
<h3 id="做过权限没？"><a href="#做过权限没？" class="headerlink" title="做过权限没？"></a>做过权限没？</h3><p>这一块讲了下自己的理解</p>
<p>实际业务开发来讲好像不太难，主要就是给一个标识，来判断到底需不要显示这个路由</p>
<p><strong>你指的标识是什么？</strong></p>
<p>就是来判断是否显示这个路由的字段，可以是一个布尔值，也可以是一个其他的什么字段。通过递归来筛选前端路由有没有这个字段，然后再调用addRoute这个方法，添加到路由中。后端返回的路由信息不能保存到store中，因为刷新store中的数据就清空了</p>
<p>从代码实现上来讲这些都是比较简单的，难的是架构（<strong>其实我也不太懂，瞎吹的</strong>），我们公司项目是用的RBAC权限设计，通过directive封装自定义指令，达到按钮级权限设计。内部主要是appenchild、removeChild 添加移除dom节点来实现</p>
<p>接着我又扯到了需求分解</p>
<h3 id="为什么离职"><a href="#为什么离职" class="headerlink" title="为什么离职"></a>为什么离职</h3><h3 id="你对自己未来发展的规划"><a href="#你对自己未来发展的规划" class="headerlink" title="你对自己未来发展的规划"></a>你对自己未来发展的规划</h3><h3 id="你是怎么规划你的学习路线的"><a href="#你是怎么规划你的学习路线的" class="headerlink" title="你是怎么规划你的学习路线的"></a>你是怎么规划你的学习路线的</h3><h3 id="你对chatgpt怎么看的"><a href="#你对chatgpt怎么看的" class="headerlink" title="你对chatgpt怎么看的"></a>你对chatgpt怎么看的</h3><p>笑了，上午才拿chatgpt帮同事解决了一个正则问题</p>
<p><strong>chatgpt只是工具</strong></p>
<h2 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h2><p>面试官说他比较关注性能优化这一块</p>
<p><strong>上来第一个问题就把我问麻了</strong></p>
<h3 id="你用过正则没，说下正则"><a href="#你用过正则没，说下正则" class="headerlink" title="你用过正则没，说下正则"></a>你用过正则没，说下正则</h3><p>上午才帮同事解决了一个正则问题，没看过正则，都是用了在学，之前看过<strong>高性能javascript</strong>，想到正则还可以做一些优化，，因为实在是记不太清了，就只是提了一嘴。</p>
<h3 id="你在项目中用了是怎么做性能优化"><a href="#你在项目中用了是怎么做性能优化" class="headerlink" title="你在项目中用了是怎么做性能优化"></a>你在项目中用了是怎么做性能优化</h3><p>简单描述了下之前在项目中遇到的下拉框卡顿问题，大数据量几十万条数据引起的卡顿，开启了虚拟列表还是出现卡顿，后面对这个组件在框架的基础上进行了三次封装，集成了分页效果，解决了这个卡顿问题</p>
<p>还有一个是动态高度引起的卡顿问题，简单描述了下实际场景，利用浏览器的开发者工具定位到某个方法，发现是某个方法执行了3s左右，造成的卡顿，由于组件封装复杂，这个方法没法优化只能叫产品改需求，</p>
<p>说了下lighthouse分析报告，因为平常用的不多，简单提了一下</p>
<p>又从构建工具上讲了下优化，vite针对于依赖预构建、分包，静态资源等可以做那些优化，</p>
<p>又讲了下cdn，cdn的缺点，强缓存和协商缓存</p>
<p>又讲了下fcp、fp、首页白屏、骨架屏等</p>
<p>代码层面也可以做优化（够了够了，把我打断了，，你已经说的挺多的了）</p>
<h3 id="csrf攻击怎么防范"><a href="#csrf攻击怎么防范" class="headerlink" title="csrf攻击怎么防范"></a>csrf攻击怎么防范</h3><p>那是去年看的东西，实在是不记得了。</p>
<p>不会的话，不用强答，不要紧，接着就跳过了</p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>知道闭包吗，，我内心已经开始组织语言了，接着来了句没事我不问，哈哈哈哈</p>
<h3 id="怎么做全局捕获"><a href="#怎么做全局捕获" class="headerlink" title="怎么做全局捕获"></a>怎么做全局捕获</h3><p>用window.addEventListener(‘error’,() &#x3D;&gt;{})</p>
<p>提到了自己的个人博客项目，用vue3+node搭了个个人博客项目，接入了阿里云日志和node性能平台，利用docker-compose搭了一个简单的apm，用wsl准备配上sentry的，但是死活安装不了，不知道是不是环境的问题，是不是应该用linux系统。</p>
<p>又说了一下对于性能监控的想法（<strong>只是说一个想法，并不一定是对的</strong>），搭一个后台管理系统，利用window.performance获取到所有性能数据，给这个后台管理系统去做可视化展示</p>
<h3 id="针对你公司的项目，你用到了哪些"><a href="#针对你公司的项目，你用到了哪些" class="headerlink" title="针对你公司的项目，你用到了哪些"></a>针对你公司的项目，你用到了哪些</h3><p>利用vite做的优化，预构建优化，分包等。</p>
<p>提到了想引入一个前端性能监控的sdk，有这个想法但是公司不看重，所以才没有实施</p>
<h3 id="刚刚说到了http，说下你见到得http头有哪些"><a href="#刚刚说到了http，说下你见到得http头有哪些" class="headerlink" title="刚刚说到了http，说下你见到得http头有哪些"></a>刚刚说到了http，说下你见到得http头有哪些</h3><p>一时真没想起来，就简单答了两个，直接跟面试官说，我不记得了，但是你让我看，我大概能知道那些头信息是干什么，面试官就没问了</p>
<p>你的简历上也提到了，会html、css，精通js</p>
<p>我连忙摆手说我不是精通js<br>面试官：哈哈哈哈</p>
<h3 id="说下js异步-1"><a href="#说下js异步-1" class="headerlink" title="说下js异步"></a>说下js异步</h3><h3 id="你欣赏vue的哪些设计"><a href="#你欣赏vue的哪些设计" class="headerlink" title="你欣赏vue的哪些设计"></a>你欣赏vue的哪些设计</h3><p>说了下compiler-core这一块，createApp，render方法</p>
<p>双端diff，这一块的设计，还有响应式</p>
<p>因为源码是去年看的，，没怎么组织好语言，这一块说的有点乱</p>
<h3 id="你擅长什么？"><a href="#你擅长什么？" class="headerlink" title="你擅长什么？"></a>你擅长什么？</h3><p>擅长什么真不好答，我想了一下，，，但是我不擅长的？？比如刚才的web安全、vite、vue3、性能优化等等等</p>
<p>面试官笑了，哈哈哈</p>
<h3 id="未来的发展方向"><a href="#未来的发展方向" class="headerlink" title="未来的发展方向"></a>未来的发展方向</h3><h3 id="你对自己未来发展的规划-1"><a href="#你对自己未来发展的规划-1" class="headerlink" title="你对自己未来发展的规划"></a>你对自己未来发展的规划</h3><p>说了下我现在正在写的项目<a href="https://github.com/lyk990/mini-vite">mini-vite</a></p>
<p>面试官说一面问的都是基础，他比较注重成长性，这也可能是他没有往深问原因吧，，最后说我还不错，在同年人里面算可以的了。</p>
<p>最后又简单聊了下，，问我住哪，我说在龙岗，说高新园上班最好在公司附近租房（这算不算暗示我可能已经面试通过了？？？），，，我说不是我不愿意，我还有女朋友，得跟她商量，</p>
<p>女朋友在哪上班？，，龙岗，，面试官又笑了，，那还是别换地方了吧，虽然一号线人多，，，</p>
<p>问我渴不渴，，等久了给我买了瓶水，，面试官非常nice，面试过程还是非常愉悦的</p>
<h2 id="三面总监面"><a href="#三面总监面" class="headerlink" title="三面总监面"></a>三面总监面</h2><p>自我介绍</p>
<h3 id="怎么改变函数的执行顺序"><a href="#怎么改变函数的执行顺序" class="headerlink" title="怎么改变函数的执行顺序"></a>怎么改变函数的执行顺序</h3><p>一下子没有get到面试官到底要问什么</p>
<p>提到了js的单线程，又说到了宏任务和微任务,.then和.catch</p>
<h3 id="异步能不能理解成多线程"><a href="#异步能不能理解成多线程" class="headerlink" title="异步能不能理解成多线程"></a>异步能不能理解成多线程</h3><p>肯定不能，这是两码事，我在阮一峰的博客上看到的，又说了下js为什么是单线程的</p>
<p>又提到了preload，prefetch</p>
<h3 id="node学了多少"><a href="#node学了多少" class="headerlink" title="node学了多少"></a>node学了多少</h3><p>想用node搭一个前后端的中间层，解决并发大数据量的问题，，但是没找到合适的视频和教程。</p>
<p>只在个人的博客上用过，简单的几个fs、path、process这些模块</p>
<h3 id="你用docker做了什么？"><a href="#你用docker做了什么？" class="headerlink" title="你用docker做了什么？"></a>你用docker做了什么？</h3><p>ci&#x2F;cd，说了下我的个人博客项目，刚开始是用gitlab搭的但是没成功，后面尝试用github action去搭，发现这好像已经不太属于前端的内容了，有点偏离我的学习路线了，而且这一块好像也挺复杂的，也就没有再继续了</p>
<p>搭建前端apm，我还准备讲下部署的，但是因为不太会，所以就没讲了</p>
<h3 id="你对自己未来发展的规划-2"><a href="#你对自己未来发展的规划-2" class="headerlink" title="你对自己未来发展的规划"></a>你对自己未来发展的规划</h3><h3 id="你现在在看哪些书"><a href="#你现在在看哪些书" class="headerlink" title="你现在在看哪些书"></a>你现在在看哪些书</h3><h3 id="最后也跟我说了，要在公司附近租房"><a href="#最后也跟我说了，要在公司附近租房" class="headerlink" title="最后也跟我说了，要在公司附近租房"></a>最后也跟我说了，要在公司附近租房</h3><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>如果是在高新园上班的话，最好要在高新园附近租房</strong></p>
<p>另外，回答的时候最好是扩展开讲，不能面试官问一就答一，不知道或者不太了解的问题试着随便扯下看能不能扯到自己知道的那一块，但是别瞎扯，还有就是引导面试官问问题（？？？但是我提到了好多次vite面试官都没问），可能是因为我一年半的经验，没有深入性的去问，问的都比较浅，好像更多的都是在关注我个人的规划。</p>
<p>面试过程，从开始到结束差不多三个小时，两点半面到五点半，中间还穿插着一些等待时间，总体上来说，三次面试还是非常愉快的，，感觉三个面试官都非常nice，面试的过程也是非常愉悦，三面是总监面的，，总监面完还把我送到门口，</p>
<p><strong>最后结果呢？？ 那肯定是挂了啊</strong></p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>大家如果对vite感兴趣，欢迎关注我的vite项目：<a href="https://juejin.cn/post/7239173192493514808">写了个辅助学习vite的小工具（mini-vite）</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端面试</tag>
      </tags>
  </entry>
  <entry>
    <title>输入一个URL发生了什么</title>
    <url>/posts/42625f19/</url>
    <content><![CDATA[<h3 id="用户输入"><a href="#用户输入" class="headerlink" title="用户输入"></a>用户输入</h3><p>当用户开始在导航栏上面输入内容的时候。UI线程要进行一系列的解析来判定是将用户输入发送给搜索引擎还是直接请求你输入的站点资源。</p>
<ul>
<li>如果是搜索内容，地址栏会使用浏览器默认的搜索引擎，来合成新的带搜索关键字的 URL。</li>
<li>如果判断输入内容符合 URL 规则，比如输入的是 time.geekbang.org，那么地址栏会根据规则，把这段内容加上协议，合成为完整的 URL。</li>
</ul>
<p>当用户按下回车键的时候，UI线程会通知网络进程初始化一个网络请求来获取站点的内容。</p>
<p>这时候tab上的icon会展示一个提示资源正在加载中的旋转圈圈，而且网络进程会进行一系列诸如DNS寻址以及为请求建立TLS连接的操作。</p>
<ul>
<li>tips: 这时如果网络进程收到服务器的HTTP 301重定向响应，它就会告知UI线程进行重定向然后它会再次发起一个新的网络请求。</li>
</ul>
<p>当用户输入关键字并键入回车之后，这意味着当前页面即将要被替换成新的页面，不过在这个流程继续之前，浏览器还给了当前页面一次执行 beforeunload 事件的机会，beforeunload 事件允许页面在退出之前执行一些数据清理操作，还可以询问用户是否要离开当前页面，比如当前页面可能有未提交完成的表单等情况，因此用户可以通过 beforeunload 事件来取消导航，让浏览器不再执行任何后续工作。</p>
<p>当浏览器刚开始加载一个地址之后，标签页上的图标便进入了加载状态（loading）。但此时图中页面显示的依然是之前打开的页面内容，并没立即替换为需要跳转的页面。因为需要等待提交文档阶段，页面内容才会被替换。</p>
<h3 id="URL请求过程"><a href="#URL请求过程" class="headerlink" title="URL请求过程"></a>URL请求过程</h3><p>接下来，便进入了页面资源请求过程。这时，浏览器主进程收到了地址栏的用户输入，</p>
<p><strong>因为浏览器是分为</strong></p>
<ul>
<li><strong>Browser(一个) - 浏览器进程</strong>, 只有一个浏览器进程，负责浏览器的主体部分，包括导航栏，书签， 前进和后退按钮, 提供存储等功能</li>
<li><strong>Network(一个) - 网络进程</strong>, 主要负责页面的<strong>网络资源加载</strong>，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程</li>
<li><strong>GPU(一个) - 图像渲染进程</strong>, 其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。负责独立于其它进程的GPU任务。它之所以被独立为一个进程是因为它要处理来自于不同tab的渲染请求并把它在同一个界面上画出来。</li>
<li><strong>Extensions(多个) - 扩展程序进程</strong></li>
<li><strong>其他进程</strong> - 工具进程，辅助框架等等</li>
</ul>
<p>浏览器发起请求是需要调用网络进程的，因为进程之间的内容是需要相互隔离的，进程隔离是为保护操作系统中进程互不干扰的技术，每一个进程只能访问自己占有的数据，也就避免出现进程 A 写入数据到进程 B 的情况。正是因为进程之间的数据是严格隔离的，当需要跨进程通信的时候，浏览器进程会通过进程间通信机制（IPC）把 URL 请求发送至网络进程。</p>
<p>网络进程接收到 URL 请求后，会在这里发起真正的 URL 请求流程。</p>
<p>首先，网络进程会查找本地缓存是否缓存了该资源。如果有缓存资源，那么直接返回资源给浏览器进程；如果在缓存中没有查找到资源，那么直接进入网络请求流程。这请求前的第一步是要进行 DNS 解析，以获取请求域名的服务器 IP 地址。</p>
<p><strong>DNS解析</strong></p>
<p>因为ip地址是一种用于互联网上访问内容的虚拟地址，要想访问他人的网络就要记住ip地址才行，因为互联网不能通过域名直接访问，系统就会去hosts文件里，去查询这个域名对应的ip地址是什么。然后电脑会去访问这个ip。因为电脑不可能保存所有的域名和对应的ip地址。所以单独出来了一个服务器，让服务器去专门存储这个世界上<strong>绝大多数域名</strong>和ip的映射表，这个服务器就是dns服务器。</p>
<p>如果请求协议是 HTTPS，那么还需要建立 TLS 连接。</p>
<p>接下来就是利用 IP 地址和服务器建立 TCP 连接。连接建立之后，浏览器端会构建请求行、请求头等信息，并把和该域名相关的 Cookie 等数据附加到请求头中，然后向服务器发送构建的请求信息。</p>
<p>服务器接收到请求信息后，会根据请求信息生成响应数据（包括响应行、响应头和响应体等信息），并发给网络进程。等网络进程接收了响应行和响应头之后，就开始解析响应头的内容了。</p>
<p>在接收到服务器返回的响应头后，网络进程开始解析响应头，如果发现返回的状态码是 301 或者 302，那么说明服务器需要浏览器重定向到其他 URL。这时网络进程会从响应头的 Location 字段里面读取重定向的地址，然后再发起新的 HTTP 或者 HTTPS 请求，一切又重头开始了。</p>
<p><strong>在导航过程中，如果服务器响应行的状态码包含了 301、302 一类的跳转信息，浏览器会跳转到新的地址继续导航；如果响应行是 200，那么表示浏览器可以继续处理该请求。</strong></p>
<h4 id="响应数据处理"><a href="#响应数据处理" class="headerlink" title="响应数据处理"></a>响应数据处理</h4><p>在处理了跳转信息之后，浏览器会根据 Content-Type 的值来决定如何显示响应体的内容。</p>
<p>不同 Content-Type 的后续处理流程也截然不同。如果 Content-Type 字段的值被浏览器判断为下载类型，那么该请求会被提交给浏览器的下载管理器，同时该 URL 请求的导航流程就此结束。但如果是 HTML，那么浏览器则会继续进行导航流程。由于 Chrome 的页面渲染是运行在渲染进程中的，所以接下来就需要准备渲染进程了。</p>
<p>网络进程在把内容交给渲染进程之前还会对内容做SafeBrowsing检查，如果请求的域名或者响应的内容和某个已知的病毒网站相匹配，网络进程会给用户展示一个警告的页面。除此之外，网络进程还会做CORB（Cross Origin Read Blocking）检查来确定那些敏感的跨站数据不会被发送至渲染进程。</p>
<h5 id="寻找一个渲染进程来绘制页面"><a href="#寻找一个渲染进程来绘制页面" class="headerlink" title="寻找一个渲染进程来绘制页面"></a>寻找一个渲染进程来绘制页面</h5><p>在网络进程做完所有的检查后并且能够确定浏览器应该导航到该请求的站点，它就会告诉UI线程所有的数据都已经被准备好了。</p>
<p>UI线程在收到网络进程的确认后会为这个网站寻找一个渲染进程（renderer process）来渲染界面</p>
<p>因为网络请求的耗时可能会很长, 所以第二步中当UI线程发送URL链接给网络进程后，它其实已经知晓它们要被导航到哪个站点了。</p>
<p>所以在网络进程干活的时候，UI线程会主动地为这个网络请求启动一个渲染线程。如果一切顺利的话（没有重定向之类的东西出现），网络进程准备好数据后页面的渲染进程已经就准备好了，这就节省了新建渲染进程的时间。</p>
<p>不过如果发生诸如网站被重定向到不同站点的情况，刚刚那个渲染进程就不能被使用了，它会被摒弃，一个新的渲染进程会被启动。</p>
<h5 id="提交导航"><a href="#提交导航" class="headerlink" title="提交导航"></a>提交导航</h5><p>到这一步的时候，数据和渲染进程都已经准备好了，浏览器进程（browser process）会通过IPC告诉渲染进程去提交本次导航（commit navigation）。</p>
<p>除此之外浏览器进程还会将刚刚接收到的响应数据流传递给对应的渲染进程让它继续接收到来的HTML数据。</p>
<p>一旦浏览器进程收到渲染线程的回复说导航已经被提交了（commit），导航这个过程就结束了，文档的加载阶段（document loading phase）会正式开始。</p>
<p>到了这个时候，导航栏会被更新，安全指示符和站点设置会展示新页面相关的站点信息。 当前tab的会话历史（session history）也会被更新，这样当你点击浏览器的前进和后退按钮也可以导航到刚刚导航完的页面。为了方便你在关闭了tab或窗口（window）的时候还可以恢复当前tab和会话（session）内容，当前的会话历史会被保存在磁盘上面。</p>
<h5 id="加载完成"><a href="#加载完成" class="headerlink" title="加载完成"></a>加载完成</h5><p>当导航提交完成后，渲染进程开始着手加载资源以及渲染页面。</p>
<p>一旦渲染进程完成渲染（load），它会通过IPC告知浏览器进程，然后UI线程就会停止导航栏上旋转的圈圈。</p>
<h4 id="准备渲染进程"><a href="#准备渲染进程" class="headerlink" title="准备渲染进程"></a>准备渲染进程</h4><p>到这一步的时候，数据和渲染进程都已经准备好了，浏览器进程（browser process）会通过IPC告诉渲染进程去提交本次导航（commit navigation）。</p>
<p>除此之外浏览器进程还会将刚刚接收到的响应数据流传递给对应的渲染进程让它继续接收到来的HTML数据。</p>
<p>一旦浏览器进程收到渲染线程的回复说导航已经被提交了（commit），导航这个过程就结束了，文档的加载阶段（document loading phase）会正式开始。</p>
<p>到了这个时候，导航栏会被更新，安全指示符和站点设置会展示新页面相关的站点信息。当前tab的会话历史（session history）也会被更新，这样当你点击浏览器的前进和后退按钮也可以导航到刚刚导航完的页面。为了方便你在关闭了tab或窗口（window）的时候还可以恢复当前tab和会话（session）内容，当前的会话历史会被保存在磁盘上面。</p>
<p>默认情况下，Chrome 会为每个页面分配一个渲染进程，也就是说，每打开一个新页面就会配套创建一个新的渲染进程。但是，也有一些例外，在某些情况下，浏览器会让多个页面直接运行在同一个渲染进程中。</p>
<p><strong>那什么情况下多个页面会同时运行在一个渲染进程中呢？</strong></p>
<p>要解决这个问题，我们就需要先了解下什么是同一站点（same-site）。具体地讲，我们将“同一站点”定义为根域名（例如，geekbang.org）加上协议（例如，https:&#x2F;&#x2F; 或者 http:&#x2F;&#x2F;），还包含了该根域名下的所有子域名和不同的端口，比如下面这三个：</p>
<pre><code>https://time.geekbang.org
https://www.geekbang.org
https://www.geekbang.org:8080
</code></pre>
<p>Chrome 的默认策略是，每个标签对应一个渲染进程。但如果从一个页面打开了另一个新页面，而新页面和当前页面属于同一站点的话，那么新页面会复用父页面的渲染进程。官方把这个默认策略叫 process-per-site-instance。</p>
<p>总结来说，打开一个新页面采用的渲染进程策略就是：</p>
<ul>
<li>通常情况下，打开新的页面都会使用单独的渲染进程；</li>
<li>如果从 A 页面打开 B 页面，且 A 和 B 都属于同一站点的话，那么 B 页面复用 A 页面的渲染进程；如果是其他情况，浏览器进程则会为 B 创建一个新的渲染进程。</li>
</ul>
<p>渲染进程准备好之后，还不能立即进入文档解析状态，因为此时的文档数据还在网络进程中，并没有提交给渲染进程，所以下一步就进入了提交文档阶段。</p>
<h4 id="提交文档"><a href="#提交文档" class="headerlink" title="提交文档"></a>提交文档</h4><p>所谓提交文档，就是指浏览器进程将网络进程接收到的 HTML 数据提交给渲染进程，具体流程是这样的：</p>
<ul>
<li>首先当浏览器进程接收到网络进程的响应头数据之后，便向渲染进程发起“提交文档”的消息；</li>
<li>渲染进程接收到“提交文档”的消息后，会和网络进程建立传输数据的“管道”；</li>
<li>等文档数据传输完成之后，渲染进程会返回“确认提交”的消息给浏览器进程；</li>
<li>浏览器进程在收到“确认提交”的消息后，会更新浏览器界面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web 页面。</li>
</ul>
<p>其中，当渲染进程确认提交之后，更新内容如下图所示：</p>
<p><img src="https://lyk990-my-blog.oss-cn-shenzhen.aliyuncs.com/computer-basic/input-url-what-happen/input-url-what-happened.png" alt="image-20221005134118852.png"><br>这也就解释了为什么在浏览器的地址栏里面输入了一个地址后，之前的页面没有立马消失，而是要加载一会儿才会更新页面。</p>
<h4 id="渲染阶段"><a href="#渲染阶段" class="headerlink" title="渲染阶段"></a>渲染阶段</h4><p>一旦页面生成完成，渲染进程会发送一个消息给浏览器进程，浏览器接收到消息后，会停止标签图标上的加载动画。</p>
<p>渲染进程的主要任务是将HTML，CSS，以及JavaScript转变为我们可以进程交互的网页内容。</p>
<p>渲染进程里面有：一个主线程（main thread），几个工作线程（worker threads），一个合成线程（compositor thread）以及一个光栅线程（raster thread）</p>
<p>在渲染进程里面，主线程（main thread）处理了绝大多数你发送给用户的代码。如果你使用了web worker或者service worker，相关的代码将会由工作线程（worker thread）处理。合成（compositor）以及光栅（raster）线程运行在渲染进程里面用来高效流畅地渲染出页面内容。</p>
<h5 id="构建Dom"><a href="#构建Dom" class="headerlink" title="构建Dom"></a>构建Dom</h5><p>渲染进程在导航结束的时候会收到来自浏览器进程提交导航的消息，在这之后渲染进程就会开始接收HTML数据，同时主线程也会开始解析接收到的文本数据，并把它转化为一个DOM（Document Object Model）对象。</p>
<p>上面提到过，渲染进程在导航结束的时候会收到来自浏览器进程提交导航的消息，在这之后渲染进程就会开始接收HTML数据，同时主线程也会开始解析接收到的文本数据，并把它转化为一个DOM（Document Object Model）对象。</p>
<p>DOM对象既是浏览器对当前页面的内部表示，也是Web开发人员通过JavaScript与网页进行交互的数据结构以及API。</p>
<p>如何将HTML文档解析为DOM对象是在HTML标准中定义的。</p>
<p>不过在你的web开发生涯中，你可能从来没有遇到过浏览器在解析HTML的时候发生错误的情景。</p>
<p>这是因为浏览器对HTML的错误容忍度很大。举些例子：如果一个段落缺失了闭合p标签（</p>），这个页面还是会被当做为有效的HTML来处理；</p>
<pre><code>Hi! &lt;b&gt;I&#39;m &lt;i&gt;Chrome&lt;/b&gt;!&lt;/i&gt; 
</code></pre>
<p>虽然有语法错误，不过浏览器会把它处理为</p>
<pre><code>Hi! &lt;b&gt;I&#39;m &lt;i&gt;Chrome&lt;/i&gt;&lt;/b&gt;&lt;i&gt;!&lt;/i&gt;。
</code></pre>
<h5 id="子资源加载"><a href="#子资源加载" class="headerlink" title="子资源加载"></a>子资源加载</h5><p>除了HTML文件，网站通常还会使用到一些诸如图片，CSS样式以及JavaScript脚本等子资源，这些文件会从缓存或者网络上获取。</p>
<p>主线程会按照在构建DOM树时遇到各个资源的循序一个接着一个地发起网络请求，为了提升效率，浏览器会同时运行“预加载扫描”程序。</p>
<p>如果在HTML文档里面存在诸如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;img src=&quot;转存失败，建议直接上传图片文件 &quot; alt=&quot;转存失败，建议直接上传图片文件&quot;&gt;</span><br><span class="line"></span><br><span class="line">或者&lt;link&gt;这样的标签，</span><br></pre></td></tr></table></figure>
<p>预加载扫描程序会在HTML解析器里面找到对应要获取的资源，<strong>并把这些要获取的资源告诉浏览器进程里面的网络线程</strong></p>
<h5 id="JavaScript会阻塞HTML的解析过程"><a href="#JavaScript会阻塞HTML的解析过程" class="headerlink" title="JavaScript会阻塞HTML的解析过程"></a>JavaScript会阻塞HTML的解析过程</h5><p>当HTML解析器碰到script标签的时候，它会停止HTML文档的解析从而转向JavaScript代码的加载，解析以及执行。</p>
<p>为什么要这样做呢？因为script标签中的JavaScript可能会使用诸如document.write()这样的代码改变文档流（document）的形状，从而使整个DOM树的结构发生根本性的改变。因为这个原因，HTML解析器不得不等JavaScript执行完成之后才能继续对HTML文档流的解析工作。</p>
<p>开发者可以通过很多方式告诉浏览器如何才能更加优雅地加载网页需要用到的资源。比如你可以为script标签添加一个async或者defer属性来使JavaScript脚本进行异步加载。<link rel="preload">资源预加载可以用来告诉浏览器这个资源在当前的导航肯定会被用到，你想要尽快加载这个资源。</p>
<h5 id="样式计算-CSS"><a href="#样式计算-CSS" class="headerlink" title="样式计算 CSS"></a>样式计算 CSS</h5><p>主线程会解析页面的CSS从而确定每个DOM节点的计算样式（computed style）。计算样式是主线程根据CSS样式选择器（CSS selectors）计算出的每个DOM元素应该具备的具体样式，即使你的页面没有设置任何自定义的样式，每个DOM节点还是会有一个计算样式属性，这是因为每个浏览器都有自己的默认样式表。 因为这个样式表的存在，页面上的h1标签一定会比h2标签大，而且不同的标签会有不同的magin和padding</p>
<h5 id="布局-Layout"><a href="#布局-Layout" class="headerlink" title="布局 Layout"></a>布局 Layout</h5><p>前面这些步骤完成之后，渲染进程就已经知道页面的具体文档结构以及每个节点拥有的样式信息了，可是这些信息还是不能最终确定页面的样子.</p>
<p>只知道网站的文档流以及每个节点的样式是远远不足以渲染出页面内容的，还需要通过布局（layout）来计算出每个节点的几何信息。</p>
<p>布局的具体过程是：</p>
<ol start="0">
<li>主线程会遍历刚刚构建的DOM树，根据DOM节点的计算样式计算出一个布局树（layout tree）。</li>
<li>布局树上每个节点会有它在页面上的x，y坐标以及盒子大小（bounding box sizes）的具体信息。布局树长得和先前构建的DOM树差不多，不同的是这颗树只有那些可见的（visible）节点信息。</li>
</ol>
<p>举个例子，如果一个节点被设置为了display:none，这个节点就是不可见的就不会出现在布局树上面（visibility:hidden的节点会出现在布局树上面）。同样的，如果一个伪元素（pseudo class）节点有诸如p::before{content:”Hi!”}这样的内容，它会出现在布局上，而不存在于DOM树上。</p>
<h5 id="绘画"><a href="#绘画" class="headerlink" title="绘画"></a>绘画</h5><p>知道了DOM节点以及它的样式和布局其实还是不足以渲染出页面来的。</p>
<p>为什么呢？举个例子，假如你现在想对着一幅画画一幅一样的画，你已经知道了画布上每个元素的大小，形状以及位置，你还是得思考一下每个元素的绘画顺序，因为画布上的元素是会互相遮挡的（z-index）。</p>
<p>如果页面上的某些元素设置了z-index属性，绘制元素的顺序就会影响到页面的正确性。</p>
<h5 id="合成"><a href="#合成" class="headerlink" title="合成"></a>合成</h5><p>浏览器已经知道了关于页面以下的信息：文档结构，元素的样式，元素的几何信息以及它们的绘画顺序。那么浏览器是如何利用这些信息来绘制出页面来的呢？将以上这些信息转化为显示器的像素的过程叫做光栅化（rasterizing）。</p>
<p>现代浏览器采用合成的方式, 来展示整个页面</p>
<p>合成是一种将页面分成若干层，然后分别对它们进行光栅化，最后在一个单独的线程 - 合成线程（compositor thread）里面合并成一个页面的技术。当用户滚动页面时，由于页面各个层都已经被光栅化了，浏览器需要做的只是合成一个新的帧来展示滚动后的效果罢了。页面的动画效果实现也是类似，将页面上的层进行移动并构建出一个新的帧即可。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://time.geekbang.org/column/intro/100033601">浏览器工作原理与实践</a></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>前端面试</tag>
      </tags>
  </entry>
  <entry>
    <title>面试官：说一下vue3响应式</title>
    <url>/posts/eb0b5d9f/</url>
    <content><![CDATA[<h2 id="第一层回答"><a href="#第一层回答" class="headerlink" title="第一层回答"></a>第一层回答</h2><blockquote>
<p>按照源码实现来回答</p>
</blockquote>
<ul>
<li>proxy、reflect</li>
</ul>
<p>创建proxy代理对象，监听用户的get、set操作，再通过reflect反射给代理对象</p>
<p>当get时会track（收集依赖），当set时会trigger（触发依赖）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">reactive</span>(<span class="params">raw</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>(raw, &#123;</span><br><span class="line">        <span class="title function_">get</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">get</span>(get, key)</span><br><span class="line">            <span class="comment">// 执行收集依赖操作</span></span><br><span class="line">            <span class="title function_">track</span>(target, key);</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">set</span>(<span class="params">target, key, value</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, value)</span><br><span class="line">            <span class="comment">// 执行触发依赖操作</span></span><br><span class="line">            <span class="title function_">trigger</span>(target, key);</span><br><span class="line">            retrun res</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>effect依赖收集、触发依赖</li>
</ul>
<p>收集响应式对象的fn，创建effect，执行fn，触发get操作，执行track方法，把effect收集起来作为依赖</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 依赖收集</span></span><br><span class="line"><span class="keyword">const</span> targetMap = <span class="keyword">new</span> <span class="title class_">WeakMap</span>&lt;any, <span class="title class_">KeyToDepMap</span>&gt;()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">ReactiveEffect</span>&lt;T = any&gt; &#123;</span><br><span class="line">  active = <span class="literal">true</span></span><br><span class="line">  <span class="attr">deps</span>: <span class="title class_">Dep</span>[] = [] </span><br><span class="line">  onStop?: <span class="function">() =&gt;</span> <span class="keyword">void</span></span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">   <span class="title function_">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params">    public fn: () =&gt; T,</span></span><br><span class="line"><span class="params">    public scheduler: EffectScheduler | <span class="literal">null</span> = <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">    scope?: EffectScope</span></span><br><span class="line"><span class="params">  </span>) &#123;</span><br><span class="line">    <span class="title function_">recordEffectScope</span>(<span class="variable language_">this</span>, scope)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="title function_">run</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 在源码中,这里面还有很多操作,这里为了精简</span></span><br><span class="line">    <span class="comment">// 就简单写一下</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">fn</span>()</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">stop</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">onStop</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">onStop</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 依赖收集，传入的fn会触发get操作，同时收集fn</span></span><br><span class="line"><span class="comment">// 对响应式对象进行set操作时，会触发所收集的fn</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">effect</span>(<span class="params">fn, options</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> _effect = <span class="keyword">new</span> <span class="title class_">ReactiveEffect</span>(fn)</span><br><span class="line">  <span class="title function_">extend</span>(_effect, options)</span><br><span class="line">   _effect.<span class="title function_">run</span>()</span><br><span class="line">  <span class="keyword">const</span> runner = _effect.<span class="property">run</span>.<span class="title function_">bind</span>(_effect) </span><br><span class="line">  runner.<span class="property">effect</span> = _effect</span><br><span class="line">  <span class="keyword">return</span> runner</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>track 在触发get的时候进行依赖收集</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> targetMap = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">track</span>(<span class="params">target, type, key: unknown</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (shouldTrack &amp;&amp; activeEffect) &#123;</span><br><span class="line">    <span class="keyword">let</span> depsMap = targetMap.<span class="title function_">get</span>(target)</span><br><span class="line">    <span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">      targetMap.<span class="title function_">set</span>(target, (depsMap = <span class="keyword">new</span> <span class="title class_">Map</span>()))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> dep = depsMap.<span class="title function_">get</span>(key)</span><br><span class="line">    <span class="keyword">if</span> (!dep) &#123;</span><br><span class="line">      depsMap.<span class="title function_">set</span>(key, (dep = <span class="title function_">createDep</span>()))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> eventInfo = __DEV__</span><br><span class="line">      ? &#123; <span class="attr">effect</span>: activeEffect, target, type, key &#125;</span><br><span class="line">      : <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_">trackEffects</span>(dep, eventInfo)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>trigger在触发set的时候进行触发依赖</li>
</ul>
<p>先取出来之前存起来的depsMap，遍历，然后effect.run()执行依赖</p>
<p>修改响应式对象的值的、触发set操作、执行trigger、重新运行effect函数，执行fn、触发get操作，执行track方法，把effect收集起来作为依赖</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 触发set的时候会触发依赖</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">trigger</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> depsMap = targetMap.<span class="title function_">get</span>(target)</span><br><span class="line">    <span class="keyword">let</span> dep = depsMap.<span class="title function_">get</span>(key)</span><br><span class="line">    <span class="comment">// 遍历之前收集到的所有的fn，然后调用它</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> effect <span class="keyword">of</span> dep) &#123;</span><br><span class="line">        effect.<span class="title function_">run</span>( )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="第二层回答"><a href="#第二层回答" class="headerlink" title="第二层回答"></a>第二层回答</h2><blockquote>
<p>结合架构及设计思想回答</p>
</blockquote>
<p>如果从这个角度来回答问题,就需要了解一下vue3的设计思想</p>
<p> <strong>响应式数据驱动</strong>：将数据与 DOM 元素绑定，一旦数据发生变化，相关的 DOM 元素会自动更新，无需手动操作 DOM。</p>
<p> <strong>组件化开发</strong>：将应用程序拆分为多个可复用的组件。每个组件都有自己的状态和逻辑，可以嵌套组合以构建复杂的用户界面。组件化开发使代码更易于维护和理解，同时提高了代码的可复用性。</p>
<p> <strong>单文件组件</strong>：单文件组件 (Single File Components，<code>SFC</code>) 这种方式将模板、脚本和样式都封装在一个文件中，使开发更加模块化和可维护。</p>
<p> <strong>虚拟 DOM</strong>：在内存中建立一个虚拟的 DOM 树，然后与实际 DOM 进行比较，只更新实际改变的部分，从而减少了 DOM 操作的开销，提高了渲染效率。</p>
<p>  <strong>指令系统</strong>：提供了一套强大的指令系统，允许开发人员直接操作 DOM。除了内置的指令，还可以自定义指令以满足特定需求。</p>
<p>  <strong>路由管理</strong>：通常与 Vue Router 配合使用，以实现单页面应用 (<code>SPA</code>) 的路由管理。Vue Router 允许你定义路由和视图之间的映射关系，实现无刷新页面切换。</p>
<p>  <strong>状态管理</strong>：通常与 Vuex 配合使用，以管理应用程序的状态。Vuex 提供了一个集中的状态存储，用于跨组件共享状态和管理复杂的应用程序状态逻辑。</p>
<p>  <strong>插件系统</strong>：支持插件系统，这使得社区可以为 Vue 提供丰富的插件和扩展，以满足不同的需求。</p>
<p>  <strong>渐进式框架</strong>：用你想用或者能用的功能特性，你不想用的部分功能可以先不用</p>
<p>Vue3的核心设计思想之一就是响应式, 它采用的是MVVM架构,</p>
<p>在<code>视图层</code>(View)和<code>数据层</code>(Model)之间建立一个<code>视图层</code>(ViewModel),通过观察者模式和采用代理反射的方式,进行数据劫持和数据绑定,实现响应式系统,我们在开发时只需要关心数据就行,vue能够实现自动的数据更新和 DOM 渲染</p>
<p>响应式系统将数据与视图绑定起来。这对于单页面应用非常重要，<code>单页面应用</code>（SPA）是一种特殊类型的 Web 应用程序，其特点是在用户与应用程序交互时不会重新加载整个页面。相反，SPA 通过动态地替换页面的一部分来实现页面切换和内容更新</p>
<p>因为它们通常需要在用户与应用程序交互时动态更新内容，而不需要进行完整的页面刷新。响应式系统使得数据变化后视图会自动更新，</p>
<p>Vue 3 的响应式系统为单页面应用提供了一种高效的方式来管理和响应数据的变化，同时，Vue3提供的组件化开发、路由管理、状态管理等工具也使得构建复杂的单页面应用变得更加容易</p>
<h2 id="第三层回答"><a href="#第三层回答" class="headerlink" title="第三层回答"></a>第三层回答</h2><blockquote>
<p>为什么要做响应式这样的设计,它的出现解决了什么问题,它存在哪些缺陷?</p>
</blockquote>
<p>Vue 3 的核心设计思想之一是数据驱动视图，这意味着可以使用 Vue 3 的响应式系统将数据与视图绑定起来,开发者在开发时只需要关心数据状态和逻辑就行,使用响应式系统的能提供一种简单、高效的方式来管理前端应用程序的数据和界面，这极大的降低了开发门槛</p>
<p>同时,Vue 的响应式系统使用虚拟 DOM 来最小化实际 DOM 操作的次数，从而提高性能。只有在必要时才会进行实际 DOM 更新，减少了开销</p>
<p>但是它还存在一些问题,</p>
<ul>
<li><p>Vue 的响应式系统使用虚拟 DOM 来最小化实际 DOM 操作的次数，但对于大型应用或频繁数据变化的情况，仍然可能导致性能开销较大</p>
</li>
<li><p>Vue 响应式系统需要为每个响应式数据对象维护一个依赖图，这可能导致一些内存开销，尤其是在具有大量响应式数据的应用中</p>
</li>
<li><p>响应式数据和计算属性的管理可能会变得复杂</p>
</li>
<li><p>Vue 响应式系统在跨组件通信方面的能力有限。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端面试</tag>
      </tags>
  </entry>
  <entry>
    <title>以一名初级前端的视角来理解架构</title>
    <url>/posts/b928cd19/</url>
    <content><![CDATA[<hr>
<blockquote>
<p>先说一下我自己的观点，<strong>架构</strong>其实并没有那么的高大上，前端初学者都可以尝试去理解这个概念，并不是只有架构师才需要涉及。从代码设计，到应用设计再到系统设计，其实处处都是架构。<strong>从代码实现和具体业务中抽象出一幅有着各种各样关联性的架构图。</strong></p>
</blockquote>
<h2 id="架构思维"><a href="#架构思维" class="headerlink" title="架构思维"></a>架构思维</h2><h3 id="架构思维的建立"><a href="#架构思维的建立" class="headerlink" title="架构思维的建立"></a>架构思维的建立</h3><p>实际开发经验到一两年之后，应对大部分的业务开发应该问题不大了，这个时候可能就会自然而然的思考，各种组件封装，函数封装等，让自己的代码尽量不那么的’shit’，这个时候其实就开始建立起了代码设计层级的思考了</p>
<h4 id="代码级设计"><a href="#代码级设计" class="headerlink" title="代码级设计"></a>代码级设计</h4><p>从各种各样的名词：<strong>高内聚、低耦合、健壮性、可读性、复用性、松散性、可维护、可扩展等</strong></p>
<p>从各种各样的设计模式：<strong>单例、策略、中介、工厂、发布订阅、观察者等</strong></p>
<p>从各种各样的设计原则：<strong>单一原则、最小知识原则、开放封闭原则等</strong></p>
<p>代码层面上的设计除了一系列技术上的各式各样的原则之外，还应包括各种各样的规范，比如变量命名、目录结构、代码提交等。</p>
<p>在cv久了之后，也会思考<code>模块化设计</code>和<code>组件化开发</code>，结合业务去思考模块化开发的临界条件，即什么场景下需要做封装，什么场景下需要解耦，哪些代码可以做封装，这里到底是全局统一封装还是组件内封装。会去考虑代码的各种设计，降低代码的耦合度，提高可复用性。</p>
<p>在进行模块化设计时，按功能拆分成独立的模块，每个模块负责一个特定的功能或者一组相关的功能。</p>
<p>在进行组件化开发时，将UI和业务逻辑划分为独立的组件。需要保证这些组件可以被复用，同时也是仅承担一个特定的功能</p>
<p>同时会生成自己的一套代码规范、目录规范、命名规范、代码提交规范等。</p>
<h4 id="应用级设计"><a href="#应用级设计" class="headerlink" title="应用级设计"></a>应用级设计</h4><p>应用级设计涉及整个系统的组织、结构和交互，各个应用是系统架构的进一步功能级的细化，具体的实施细则都是放在各个应用之间实现的，随着系统规模增大，代码复杂度上升。难以扩展和维护，于是便抽离出各种各样的应用设计，如状态管理、路由管理、请求处理、ui组件库等。</p>
<p>需要结合实际开发场景做不同的应用技术选型，就好比我现在开发的后台管理系统一样，它是在vben的基础上进行开发的，选择它的原因有如下几点</p>
<ul>
<li>功能强大，封装的组件和功能足以满足日常业务开发</li>
<li>vben2.10，采用monorepo架构，对于目前规划的项目后续的版本迭代会有所帮助</li>
<li>采用的技术栈最起码两年内不会过时</li>
<li>有着强大的社区生态</li>
<li>当然最重要的一点是，上家公司就是用vben开发的，对它稍微熟悉一点</li>
</ul>
<h4 id="系统级设计"><a href="#系统级设计" class="headerlink" title="系统级设计"></a>系统级设计</h4><p>我理解的系统级设计可能不仅是技术上的一些设计，它可能还囊括团队技术规范、新人培养、 团队成长、前后端联调、git工作流等各种操作。</p>
<p>从业务需求出发，确定系统的整体架构，考虑系统的规模和复杂性。选择合适的前端框架或库。</p>
<p>在项目开发前期，最好是输出各式文档，如代码规范、git规范、项目文档等，这有助于团队成员更容易理解和维护代码。 最好是能Code Review,在大家开发思维和开发经验不一致的情况下，这也许能统一大家的代码风格，同时也能避免程序员们闭门造车。文档的规范力度不一定足够，最好是能加上eslint</p>
<p>在业务开发进入正轨的时候，就可以去对项目的技术和业务进行优化，偿还之前所欠下的技术债了，同时还可以对团队或一些技术方案的设计做一些调整。</p>
<p>日常重复性的业务开发占用了大量时间，导致团队成员没有时间提升自己了。这个时候也可以考虑提升一下团队能力了，技术分享和Code Review都是非常好的方式，</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端架构管理</tag>
      </tags>
  </entry>
</search>
